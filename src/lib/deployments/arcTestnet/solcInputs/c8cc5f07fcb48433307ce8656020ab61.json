{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/BudgetAllocator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./interfaces/IERC20.sol\";\n\n/**\n * @title BudgetAllocator\n * @notice Department budget management and allocation system\n * @dev Manages department budgets, spending, and fund requests\n */\ncontract BudgetAllocator {\n    // Structs\n    struct Department {\n        uint256 id;\n        string name;\n        uint256 totalBudget;\n        uint256 spentAmount;\n        uint256 availableBalance;\n        address manager;\n        bool active;\n        uint256 createdAt;\n    }\n\n    struct FundRequest {\n        uint256 id;\n        uint256 departmentId;\n        address requester;\n        uint256 amount;\n        string reason;\n        bool approved;\n        bool rejected;\n        bool executed;\n        uint256 requestedAt;\n        address approvedBy;\n    }\n\n    struct Expense {\n        uint256 id;\n        uint256 departmentId;\n        uint256 amount;\n        string description;\n        address spentBy;\n        uint256 timestamp;\n    }\n\n    // State variables\n    address public treasury;\n    address public admin;\n    IERC20 public usdc;\n\n    mapping(uint256 => Department) public departments;\n    uint256 public departmentCount;\n\n    mapping(uint256 => FundRequest) public fundRequests;\n    uint256 public requestCount;\n\n    mapping(uint256 => Expense[]) public departmentExpenses;\n    Expense[] public allExpenses;\n\n    // Events\n    event DepartmentCreated(uint256 indexed departmentId, string name, uint256 budget, address manager);\n    event BudgetAllocated(uint256 indexed departmentId, uint256 amount);\n    event BudgetUpdated(uint256 indexed departmentId, uint256 newBudget);\n    event FundRequested(uint256 indexed requestId, uint256 indexed departmentId, uint256 amount, string reason);\n    event RequestApproved(uint256 indexed requestId, address indexed approver);\n    event RequestRejected(uint256 indexed requestId, address indexed rejector);\n    event FundsTransferred(uint256 indexed departmentId, address indexed recipient, uint256 amount);\n    event ExpenseRecorded(uint256 indexed departmentId, uint256 amount, string description);\n    event DepartmentDeactivated(uint256 indexed departmentId);\n\n    // Modifiers\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin can call\");\n        _;\n    }\n\n    modifier onlyTreasury() {\n        require(msg.sender == treasury, \"Only treasury can call\");\n        _;\n    }\n\n    modifier departmentExists(uint256 _departmentId) {\n        require(_departmentId < departmentCount, \"Department does not exist\");\n        require(departments[_departmentId].active, \"Department is inactive\");\n        _;\n    }\n\n    modifier onlyDepartmentManager(uint256 _departmentId) {\n        require(departments[_departmentId].manager == msg.sender, \"Only department manager\");\n        _;\n    }\n\n    /**\n     * @notice Initialize budget allocator\n     * @param _treasury Treasury contract address\n     * @param _usdc USDC token address\n     */\n    constructor(address _treasury, address _usdc) {\n        require(_treasury != address(0), \"Invalid treasury\");\n        require(_usdc != address(0), \"Invalid USDC address\");\n\n        treasury = _treasury;\n        admin = msg.sender;\n        usdc = IERC20(_usdc);\n    }\n\n    /**\n     * @notice Create a new department\n     * @param _name Department name\n     * @param _budget Initial budget allocation\n     * @param _manager Department manager address\n     * @return departmentId New department ID\n     */\n    function createDepartment(\n        string memory _name,\n        uint256 _budget,\n        address _manager\n    ) external onlyAdmin returns (uint256) {\n        require(bytes(_name).length > 0, \"Name required\");\n        require(_manager != address(0), \"Invalid manager\");\n\n        uint256 departmentId = departmentCount;\n\n        departments[departmentId] = Department({\n            id: departmentId,\n            name: _name,\n            totalBudget: _budget,\n            spentAmount: 0,\n            availableBalance: _budget,\n            manager: _manager,\n            active: true,\n            createdAt: block.timestamp\n        });\n\n        departmentCount++;\n\n        emit DepartmentCreated(departmentId, _name, _budget, _manager);\n\n        return departmentId;\n    }\n\n    /**\n     * @notice Allocate additional funds to a department\n     * @param _departmentId Department ID\n     * @param _amount Amount to allocate\n     */\n    function allocateFunds(uint256 _departmentId, uint256 _amount)\n        external\n        onlyAdmin\n        departmentExists(_departmentId)\n    {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        Department storage dept = departments[_departmentId];\n        dept.totalBudget += _amount;\n        dept.availableBalance += _amount;\n\n        emit BudgetAllocated(_departmentId, _amount);\n    }\n\n    /**\n     * @notice Request additional funds for a department\n     * @param _departmentId Department ID\n     * @param _amount Amount requested\n     * @param _reason Reason for request\n     * @return requestId Fund request ID\n     */\n    function requestFunds(\n        uint256 _departmentId,\n        uint256 _amount,\n        string memory _reason\n    ) external departmentExists(_departmentId) returns (uint256) {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(bytes(_reason).length > 0, \"Reason required\");\n\n        uint256 requestId = requestCount;\n\n        fundRequests[requestId] = FundRequest({\n            id: requestId,\n            departmentId: _departmentId,\n            requester: msg.sender,\n            amount: _amount,\n            reason: _reason,\n            approved: false,\n            rejected: false,\n            executed: false,\n            requestedAt: block.timestamp,\n            approvedBy: address(0)\n        });\n\n        requestCount++;\n\n        emit FundRequested(requestId, _departmentId, _amount, _reason);\n\n        return requestId;\n    }\n\n    /**\n     * @notice Approve a fund request\n     * @param _requestId Request ID\n     */\n    function approveFundRequest(uint256 _requestId) external onlyAdmin {\n        require(_requestId < requestCount, \"Request does not exist\");\n\n        FundRequest storage request = fundRequests[_requestId];\n        require(!request.approved && !request.rejected, \"Request already processed\");\n        require(!request.executed, \"Request already executed\");\n\n        request.approved = true;\n        request.approvedBy = msg.sender;\n\n        // Automatically allocate funds\n        Department storage dept = departments[request.departmentId];\n        dept.totalBudget += request.amount;\n        dept.availableBalance += request.amount;\n\n        request.executed = true;\n\n        emit RequestApproved(_requestId, msg.sender);\n        emit BudgetAllocated(request.departmentId, request.amount);\n    }\n\n    /**\n     * @notice Reject a fund request\n     * @param _requestId Request ID\n     */\n    function rejectFundRequest(uint256 _requestId) external onlyAdmin {\n        require(_requestId < requestCount, \"Request does not exist\");\n\n        FundRequest storage request = fundRequests[_requestId];\n        require(!request.approved && !request.rejected, \"Request already processed\");\n\n        request.rejected = true;\n\n        emit RequestRejected(_requestId, msg.sender);\n    }\n\n    /**\n     * @notice Record an expense for a department\n     * @param _departmentId Department ID\n     * @param _amount Expense amount\n     * @param _description Expense description\n     */\n    function recordExpense(\n        uint256 _departmentId,\n        uint256 _amount,\n        string memory _description\n    ) external departmentExists(_departmentId) onlyDepartmentManager(_departmentId) {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        Department storage dept = departments[_departmentId];\n        require(dept.availableBalance >= _amount, \"Insufficient budget\");\n\n        dept.spentAmount += _amount;\n        dept.availableBalance -= _amount;\n\n        Expense memory expense = Expense({\n            id: allExpenses.length,\n            departmentId: _departmentId,\n            amount: _amount,\n            description: _description,\n            spentBy: msg.sender,\n            timestamp: block.timestamp\n        });\n\n        departmentExpenses[_departmentId].push(expense);\n        allExpenses.push(expense);\n\n        emit ExpenseRecorded(_departmentId, _amount, _description);\n    }\n\n    /**\n     * @notice Transfer funds from department budget\n     * @param _departmentId Department ID\n     * @param _recipient Recipient address\n     * @param _amount Amount to transfer\n     */\n    function transferFunds(\n        uint256 _departmentId,\n        address _recipient,\n        uint256 _amount\n    ) external departmentExists(_departmentId) onlyDepartmentManager(_departmentId) {\n        require(_recipient != address(0), \"Invalid recipient\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        Department storage dept = departments[_departmentId];\n        require(dept.availableBalance >= _amount, \"Insufficient budget\");\n        require(address(this).balance >= _amount, \"Insufficient contract balance\");\n\n        dept.spentAmount += _amount;\n        dept.availableBalance -= _amount;\n\n        (bool success, ) = _recipient.call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        emit FundsTransferred(_departmentId, _recipient, _amount);\n    }\n\n    /**\n     * @notice Get department details\n     * @param _departmentId Department ID\n     * @return name Department name\n     * @return totalBudget Total budget allocated\n     * @return spentAmount Amount spent\n     * @return availableBalance Available balance\n     * @return manager Department manager\n     * @return active Department active status\n     */\n    function getDepartmentDetails(uint256 _departmentId)\n        external\n        view\n        returns (\n            string memory name,\n            uint256 totalBudget,\n            uint256 spentAmount,\n            uint256 availableBalance,\n            address manager,\n            bool active\n        )\n    {\n        Department memory dept = departments[_departmentId];\n        return (\n            dept.name,\n            dept.totalBudget,\n            dept.spentAmount,\n            dept.availableBalance,\n            dept.manager,\n            dept.active\n        );\n    }\n\n    /**\n     * @notice Get department balance\n     * @param _departmentId Department ID\n     * @return balance Available balance\n     */\n    function getDepartmentBalance(uint256 _departmentId)\n        external\n        view\n        departmentExists(_departmentId)\n        returns (uint256)\n    {\n        return departments[_departmentId].availableBalance;\n    }\n\n    /**\n     * @notice Get department expenses\n     * @param _departmentId Department ID\n     * @return expenses Array of expenses\n     */\n    function getDepartmentExpenses(uint256 _departmentId)\n        external\n        view\n        returns (Expense[] memory)\n    {\n        return departmentExpenses[_departmentId];\n    }\n\n    /**\n     * @notice Get total budget across all active departments\n     * @return total Total budget\n     */\n    function getTotalBudget() external view returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i < departmentCount; i++) {\n            if (departments[i].active) {\n                total += departments[i].totalBudget;\n            }\n        }\n        return total;\n    }\n\n    /**\n     * @notice Get total spent across all departments\n     * @return total Total spent\n     */\n    function getTotalSpent() external view returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i < departmentCount; i++) {\n            if (departments[i].active) {\n                total += departments[i].spentAmount;\n            }\n        }\n        return total;\n    }\n\n    /**\n     * @notice Get pending fund requests\n     * @return requests Array of pending request IDs\n     */\n    function getPendingRequests() external view returns (uint256[] memory) {\n        uint256 pendingCount = 0;\n\n        // Count pending requests\n        for (uint256 i = 0; i < requestCount; i++) {\n            if (!fundRequests[i].approved && !fundRequests[i].rejected) {\n                pendingCount++;\n            }\n        }\n\n        // Populate array\n        uint256[] memory pending = new uint256[](pendingCount);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < requestCount; i++) {\n            if (!fundRequests[i].approved && !fundRequests[i].rejected) {\n                pending[index] = i;\n                index++;\n            }\n        }\n\n        return pending;\n    }\n\n    /**\n     * @notice Deactivate a department\n     * @param _departmentId Department ID\n     */\n    function deactivateDepartment(uint256 _departmentId)\n        external\n        onlyAdmin\n        departmentExists(_departmentId)\n    {\n        departments[_departmentId].active = false;\n        emit DepartmentDeactivated(_departmentId);\n    }\n\n    /**\n     * @notice Update department manager\n     * @param _departmentId Department ID\n     * @param _newManager New manager address\n     */\n    function updateDepartmentManager(uint256 _departmentId, address _newManager)\n        external\n        onlyAdmin\n        departmentExists(_departmentId)\n    {\n        require(_newManager != address(0), \"Invalid manager\");\n        departments[_departmentId].manager = _newManager;\n    }\n\n    /**\n     * @notice Receive funds from treasury\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Get USDC balance of this contract\n     * @return balance Current USDC balance\n     */\n    function getBalance() external view returns (uint256) {\n        return usdc.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/ComplianceTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/**\n * @title ComplianceTracker\n * @notice Tracks compliance metadata for all treasury transactions\n * @dev Provides categorization, tagging, and reporting for regulatory compliance\n */\ncontract ComplianceTracker is AccessControl, Pausable {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant COMPLIANCE_OFFICER_ROLE = keccak256(\"COMPLIANCE_OFFICER_ROLE\");\n\n    enum TransactionCategory {\n        PAYROLL,\n        VENDOR_PAYMENT,\n        BUDGET_ALLOCATION,\n        INTERNAL_TRANSFER,\n        REFUND,\n        EXPENSE_REIMBURSEMENT,\n        TAX_PAYMENT,\n        LOAN,\n        INVESTMENT,\n        OTHER\n    }\n\n    enum RiskLevel {\n        LOW,\n        MEDIUM,\n        HIGH,\n        CRITICAL\n    }\n\n    struct ComplianceEntry {\n        uint256 id;\n        bytes32 transactionHash;      // Hash of the original transaction\n        address contractAddress;       // Which contract executed the transaction\n        address from;                  // Sender\n        address to;                    // Recipient\n        uint256 amount;                // Transaction amount\n\n        TransactionCategory category;\n        RiskLevel riskLevel;\n\n        string description;            // Human-readable description\n        string purpose;                // Business purpose\n        string jurisdiction;           // Legal jurisdiction (e.g., \"US\", \"EU\")\n\n        bytes32[] tags;                // Custom tags for filtering\n        string[] attachments;          // IPFS hashes of supporting documents\n\n        uint256 timestamp;\n        address recordedBy;            // Who added this entry\n        bool flagged;                  // Flagged for review\n        string flagReason;             // Reason for flagging\n\n        bool reviewed;                 // Has been reviewed by compliance\n        address reviewedBy;            // Who reviewed it\n        uint256 reviewedAt;            // When reviewed\n        string reviewNotes;            // Compliance officer notes\n    }\n\n    uint256 public entryCount;\n    mapping(uint256 => ComplianceEntry) public entries;\n    mapping(bytes32 => uint256) public transactionHashToEntry;  // Quick lookup by tx hash\n    mapping(address => uint256[]) public entriesByContract;     // Entries by contract\n    mapping(TransactionCategory => uint256[]) public entriesByCategory;  // Entries by category\n\n    // Policy configuration\n    uint256 public highRiskThreshold = 50000 * 10**6;  // $50k in USDC (6 decimals)\n    mapping(address => bool) public blacklistedAddresses;\n    mapping(string => bool) public restrictedJurisdictions;\n\n    // Events\n    event EntryRecorded(\n        uint256 indexed entryId,\n        bytes32 indexed transactionHash,\n        address indexed contractAddress,\n        TransactionCategory category,\n        uint256 amount\n    );\n\n    event EntryFlagged(\n        uint256 indexed entryId,\n        string reason,\n        address flaggedBy\n    );\n\n    event EntryReviewed(\n        uint256 indexed entryId,\n        address indexed reviewer,\n        bool approved\n    );\n\n    event EntryUpdated(uint256 indexed entryId);\n    event PolicyUpdated(string policyType, string details);\n    event AddressBlacklisted(address indexed account, string reason);\n    event AddressWhitelisted(address indexed account);\n\n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n        _grantRole(COMPLIANCE_OFFICER_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Record a new compliance entry for a transaction\n     */\n    function recordEntry(\n        bytes32 transactionHash,\n        address contractAddress,\n        address from,\n        address to,\n        uint256 amount,\n        TransactionCategory category,\n        string memory description,\n        string memory purpose,\n        string memory jurisdiction\n    ) external onlyRole(COMPLIANCE_OFFICER_ROLE) returns (uint256) {\n        require(transactionHash != bytes32(0), \"Invalid transaction hash\");\n        // Store entryId + 1 to differentiate from unset (0)\n        require(transactionHashToEntry[transactionHash] == 0, \"Entry already exists\");\n\n        uint256 entryId = entryCount++;\n\n        ComplianceEntry storage entry = entries[entryId];\n        entry.id = entryId;\n        entry.transactionHash = transactionHash;\n        entry.contractAddress = contractAddress;\n        entry.from = from;\n        entry.to = to;\n        entry.amount = amount;\n        entry.category = category;\n        entry.description = description;\n        entry.purpose = purpose;\n        entry.jurisdiction = jurisdiction;\n        entry.timestamp = block.timestamp;\n        entry.recordedBy = msg.sender;\n\n        // Auto-calculate risk level\n        entry.riskLevel = calculateRiskLevel(amount, to, jurisdiction);\n\n        // Auto-flag if necessary\n        if (entry.riskLevel == RiskLevel.HIGH || entry.riskLevel == RiskLevel.CRITICAL) {\n            entry.flagged = true;\n            entry.flagReason = \"Auto-flagged: High risk transaction\";\n        }\n\n        if (blacklistedAddresses[to]) {\n            entry.flagged = true;\n            entry.flagReason = \"Recipient is blacklisted\";\n        }\n\n        if (restrictedJurisdictions[jurisdiction]) {\n            entry.flagged = true;\n            entry.flagReason = \"Restricted jurisdiction\";\n        }\n\n        // Index the entry (store entryId + 1 to avoid confusion with unset value 0)\n        transactionHashToEntry[transactionHash] = entryId + 1;\n        entriesByContract[contractAddress].push(entryId);\n        entriesByCategory[category].push(entryId);\n\n        emit EntryRecorded(entryId, transactionHash, contractAddress, category, amount);\n\n        if (entry.flagged) {\n            emit EntryFlagged(entryId, entry.flagReason, msg.sender);\n        }\n\n        return entryId;\n    }\n\n    /**\n     * @notice Calculate risk level based on transaction parameters\n     */\n    function calculateRiskLevel(\n        uint256 amount,\n        address recipient,\n        string memory jurisdiction\n    ) internal view returns (RiskLevel) {\n        // Check amount threshold\n        if (amount >= highRiskThreshold) {\n            return RiskLevel.HIGH;\n        }\n\n        // Check blacklist\n        if (blacklistedAddresses[recipient]) {\n            return RiskLevel.CRITICAL;\n        }\n\n        // Check restricted jurisdictions\n        if (restrictedJurisdictions[jurisdiction]) {\n            return RiskLevel.HIGH;\n        }\n\n        // Medium risk for amounts between $10k and $50k\n        if (amount >= 10000 * 10**6) {\n            return RiskLevel.MEDIUM;\n        }\n\n        return RiskLevel.LOW;\n    }\n\n    /**\n     * @notice Update compliance entry with additional information\n     */\n    function updateEntry(\n        uint256 entryId,\n        string memory description,\n        string memory purpose,\n        bytes32[] memory tags,\n        string[] memory attachments\n    ) external onlyRole(COMPLIANCE_OFFICER_ROLE) {\n        require(entryId < entryCount, \"Entry does not exist\");\n\n        ComplianceEntry storage entry = entries[entryId];\n\n        if (bytes(description).length > 0) {\n            entry.description = description;\n        }\n\n        if (bytes(purpose).length > 0) {\n            entry.purpose = purpose;\n        }\n\n        if (tags.length > 0) {\n            entry.tags = tags;\n        }\n\n        if (attachments.length > 0) {\n            entry.attachments = attachments;\n        }\n\n        emit EntryUpdated(entryId);\n    }\n\n    /**\n     * @notice Flag an entry for review\n     */\n    function flagEntry(uint256 entryId, string memory reason) external onlyRole(COMPLIANCE_OFFICER_ROLE) {\n        require(entryId < entryCount, \"Entry does not exist\");\n\n        ComplianceEntry storage entry = entries[entryId];\n        entry.flagged = true;\n        entry.flagReason = reason;\n\n        emit EntryFlagged(entryId, reason, msg.sender);\n    }\n\n    /**\n     * @notice Review a flagged entry\n     */\n    function reviewEntry(\n        uint256 entryId,\n        bool approved,\n        string memory notes\n    ) external onlyRole(COMPLIANCE_OFFICER_ROLE) {\n        require(entryId < entryCount, \"Entry does not exist\");\n\n        ComplianceEntry storage entry = entries[entryId];\n        entry.reviewed = true;\n        entry.reviewedBy = msg.sender;\n        entry.reviewedAt = block.timestamp;\n        entry.reviewNotes = notes;\n\n        if (approved) {\n            entry.flagged = false;\n        }\n\n        emit EntryReviewed(entryId, msg.sender, approved);\n    }\n\n    /**\n     * @notice Get entries by date range\n     */\n    function getEntriesByDateRange(\n        uint256 startTime,\n        uint256 endTime\n    ) external view returns (uint256[] memory) {\n        require(startTime < endTime, \"Invalid date range\");\n\n        uint256 matchCount = 0;\n\n        // Count matches\n        for (uint256 i = 0; i < entryCount; i++) {\n            if (entries[i].timestamp >= startTime && entries[i].timestamp <= endTime) {\n                matchCount++;\n            }\n        }\n\n        // Collect matching IDs\n        uint256[] memory matchingEntries = new uint256[](matchCount);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < entryCount; i++) {\n            if (entries[i].timestamp >= startTime && entries[i].timestamp <= endTime) {\n                matchingEntries[index] = i;\n                index++;\n            }\n        }\n\n        return matchingEntries;\n    }\n\n    /**\n     * @notice Get entries by category\n     */\n    function getEntriesByCategory(TransactionCategory category) external view returns (uint256[] memory) {\n        return entriesByCategory[category];\n    }\n\n    /**\n     * @notice Get entries by contract\n     */\n    function getEntriesByContract(address contractAddress) external view returns (uint256[] memory) {\n        return entriesByContract[contractAddress];\n    }\n\n    /**\n     * @notice Get entries by amount range\n     */\n    function getEntriesByAmountRange(\n        uint256 minAmount,\n        uint256 maxAmount\n    ) external view returns (uint256[] memory) {\n        require(minAmount < maxAmount, \"Invalid amount range\");\n\n        uint256 matchCount = 0;\n\n        // Count matches\n        for (uint256 i = 0; i < entryCount; i++) {\n            if (entries[i].amount >= minAmount && entries[i].amount <= maxAmount) {\n                matchCount++;\n            }\n        }\n\n        // Collect matching IDs\n        uint256[] memory matchingEntries = new uint256[](matchCount);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < entryCount; i++) {\n            if (entries[i].amount >= minAmount && entries[i].amount <= maxAmount) {\n                matchingEntries[index] = i;\n                index++;\n            }\n        }\n\n        return matchingEntries;\n    }\n\n    /**\n     * @notice Get all flagged entries\n     */\n    function getFlaggedEntries() external view returns (uint256[] memory) {\n        uint256 flaggedCount = 0;\n\n        // Count flagged\n        for (uint256 i = 0; i < entryCount; i++) {\n            if (entries[i].flagged && !entries[i].reviewed) {\n                flaggedCount++;\n            }\n        }\n\n        // Collect flagged IDs\n        uint256[] memory flaggedEntries = new uint256[](flaggedCount);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < entryCount; i++) {\n            if (entries[i].flagged && !entries[i].reviewed) {\n                flaggedEntries[index] = i;\n                index++;\n            }\n        }\n\n        return flaggedEntries;\n    }\n\n    /**\n     * @notice Get entry details\n     */\n    function getEntry(uint256 entryId) external view returns (\n        bytes32 transactionHash,\n        address contractAddress,\n        address from,\n        address to,\n        uint256 amount,\n        TransactionCategory category,\n        RiskLevel riskLevel,\n        string memory description,\n        bool flagged,\n        bool reviewed\n    ) {\n        require(entryId < entryCount, \"Entry does not exist\");\n\n        ComplianceEntry storage entry = entries[entryId];\n        return (\n            entry.transactionHash,\n            entry.contractAddress,\n            entry.from,\n            entry.to,\n            entry.amount,\n            entry.category,\n            entry.riskLevel,\n            entry.description,\n            entry.flagged,\n            entry.reviewed\n        );\n    }\n\n    /**\n     * @notice Generate compliance report summary\n     */\n    function getComplianceReport(\n        uint256 startTime,\n        uint256 endTime\n    ) external view returns (\n        uint256 totalTransactions,\n        uint256 totalAmount,\n        uint256 flaggedCount,\n        uint256 highRiskCount,\n        uint256[10] memory categoryBreakdown\n    ) {\n        require(startTime < endTime, \"Invalid date range\");\n\n        for (uint256 i = 0; i < entryCount; i++) {\n            ComplianceEntry storage entry = entries[i];\n\n            if (entry.timestamp >= startTime && entry.timestamp <= endTime) {\n                totalTransactions++;\n                totalAmount += entry.amount;\n\n                if (entry.flagged) {\n                    flaggedCount++;\n                }\n\n                if (entry.riskLevel == RiskLevel.HIGH || entry.riskLevel == RiskLevel.CRITICAL) {\n                    highRiskCount++;\n                }\n\n                categoryBreakdown[uint256(entry.category)]++;\n            }\n        }\n\n        return (totalTransactions, totalAmount, flaggedCount, highRiskCount, categoryBreakdown);\n    }\n\n    /**\n     * @notice Update high risk threshold\n     */\n    function setHighRiskThreshold(uint256 newThreshold) external onlyRole(ADMIN_ROLE) {\n        highRiskThreshold = newThreshold;\n        emit PolicyUpdated(\"HIGH_RISK_THRESHOLD\", \"Threshold updated\");\n    }\n\n    /**\n     * @notice Blacklist an address\n     */\n    function blacklistAddress(address account, string memory reason) external onlyRole(ADMIN_ROLE) {\n        blacklistedAddresses[account] = true;\n        emit AddressBlacklisted(account, reason);\n    }\n\n    /**\n     * @notice Whitelist an address (remove from blacklist)\n     */\n    function whitelistAddress(address account) external onlyRole(ADMIN_ROLE) {\n        blacklistedAddresses[account] = false;\n        emit AddressWhitelisted(account);\n    }\n\n    /**\n     * @notice Restrict a jurisdiction\n     */\n    function restrictJurisdiction(string memory jurisdiction) external onlyRole(ADMIN_ROLE) {\n        restrictedJurisdictions[jurisdiction] = true;\n        emit PolicyUpdated(\"JURISDICTION_RESTRICTED\", jurisdiction);\n    }\n\n    /**\n     * @notice Unrestrict a jurisdiction\n     */\n    function unrestrictJurisdiction(string memory jurisdiction) external onlyRole(ADMIN_ROLE) {\n        restrictedJurisdictions[jurisdiction] = false;\n        emit PolicyUpdated(\"JURISDICTION_UNRESTRICTED\", jurisdiction);\n    }\n\n    /**\n     * @notice Pause contract (emergency)\n     */\n    function pause() external onlyRole(ADMIN_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause contract\n     */\n    function unpause() external onlyRole(ADMIN_ROLE) {\n        _unpause();\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n"
    },
    "contracts/PayrollManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./interfaces/IERC20.sol\";\n\n/**\n * @title PayrollManager\n * @notice Automated payroll management for treasury operations\n * @dev Handles employee management, salary payments, and payment scheduling\n */\ncontract PayrollManager {\n    // Enums\n    enum PaymentFrequency {\n        WEEKLY,      // Every 7 days\n        BIWEEKLY,    // Every 14 days\n        MONTHLY,     // Every 30 days\n        QUARTERLY    // Every 90 days\n    }\n\n    // Structs\n    struct Employee {\n        address wallet;\n        uint256 salary;\n        PaymentFrequency frequency;\n        uint256 lastPaymentTime;\n        uint256 totalPaid;\n        bool active;\n        string name;\n        uint256 addedAt;\n    }\n\n    struct PaymentRecord {\n        address employee;\n        uint256 amount;\n        uint256 timestamp;\n        uint256 paymentId;\n    }\n\n    // State variables\n    address public treasury;\n    address public admin;\n    IERC20 public usdc;\n\n    mapping(address => Employee) public employees;\n    address[] public employeeList;\n    PaymentRecord[] public paymentHistory;\n\n    uint256 public totalEmployees;\n    uint256 public activeEmployees;\n    uint256 public totalPayrollCost;\n\n    // Events\n    event EmployeeAdded(address indexed employee, string name, uint256 salary, PaymentFrequency frequency);\n    event EmployeeRemoved(address indexed employee);\n    event SalaryUpdated(address indexed employee, uint256 oldSalary, uint256 newSalary);\n    event PaymentProcessed(address indexed employee, uint256 amount, uint256 timestamp);\n    event PayrollExecuted(uint256 employeesPaid, uint256 totalAmount, uint256 timestamp);\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\n\n    // Modifiers\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin can call\");\n        _;\n    }\n\n    modifier onlyTreasury() {\n        require(msg.sender == treasury, \"Only treasury can call\");\n        _;\n    }\n\n    modifier employeeExists(address _employee) {\n        require(employees[_employee].active, \"Employee does not exist\");\n        _;\n    }\n\n    /**\n     * @notice Initialize payroll manager\n     * @param _treasury Treasury contract address\n     * @param _usdc USDC token address\n     */\n    constructor(address _treasury, address _usdc) {\n        require(_treasury != address(0), \"Invalid treasury\");\n        require(_usdc != address(0), \"Invalid USDC address\");\n\n        treasury = _treasury;\n        admin = msg.sender;\n        usdc = IERC20(_usdc);\n    }\n\n    /**\n     * @notice Add a new employee\n     * @param _employee Employee wallet address\n     * @param _name Employee name\n     * @param _salary Annual salary amount\n     * @param _frequency Payment frequency\n     */\n    function addEmployee(\n        address _employee,\n        string memory _name,\n        uint256 _salary,\n        PaymentFrequency _frequency\n    ) external onlyAdmin {\n        require(_employee != address(0), \"Invalid employee address\");\n        require(!employees[_employee].active, \"Employee already exists\");\n        require(_salary > 0, \"Salary must be greater than 0\");\n        require(bytes(_name).length > 0, \"Name required\");\n\n        employees[_employee] = Employee({\n            wallet: _employee,\n            salary: _salary,\n            frequency: _frequency,\n            lastPaymentTime: 0,\n            totalPaid: 0,\n            active: true,\n            name: _name,\n            addedAt: block.timestamp\n        });\n\n        employeeList.push(_employee);\n        totalEmployees++;\n        activeEmployees++;\n\n        emit EmployeeAdded(_employee, _name, _salary, _frequency);\n    }\n\n    /**\n     * @notice Remove an employee\n     * @param _employee Employee address to remove\n     */\n    function removeEmployee(address _employee) external onlyAdmin employeeExists(_employee) {\n        employees[_employee].active = false;\n        activeEmployees--;\n\n        emit EmployeeRemoved(_employee);\n    }\n\n    /**\n     * @notice Update employee salary\n     * @param _employee Employee address\n     * @param _newSalary New salary amount\n     */\n    function updateSalary(address _employee, uint256 _newSalary)\n        external\n        onlyAdmin\n        employeeExists(_employee)\n    {\n        require(_newSalary > 0, \"Salary must be greater than 0\");\n\n        uint256 oldSalary = employees[_employee].salary;\n        employees[_employee].salary = _newSalary;\n\n        emit SalaryUpdated(_employee, oldSalary, _newSalary);\n    }\n\n    /**\n     * @notice Process payroll for all eligible employees\n     * @return employeesPaid Number of employees paid\n     * @return totalPaid Total amount paid\n     */\n    function processPayroll() external returns (uint256 employeesPaid, uint256 totalPaid) {\n        uint256 count = 0;\n        uint256 total = 0;\n\n        for (uint256 i = 0; i < employeeList.length; i++) {\n            address empAddress = employeeList[i];\n            Employee storage emp = employees[empAddress];\n\n            if (emp.active && isPaymentDue(empAddress)) {\n                uint256 paymentAmount = calculatePaymentAmount(empAddress);\n\n                if (address(this).balance >= paymentAmount) {\n                    _processPayment(empAddress, paymentAmount);\n                    count++;\n                    total += paymentAmount;\n                }\n            }\n        }\n\n        if (count > 0) {\n            emit PayrollExecuted(count, total, block.timestamp);\n        }\n\n        return (count, total);\n    }\n\n    /**\n     * @notice Process payment for a specific employee\n     * @param _employee Employee address\n     */\n    function processEmployeePayment(address _employee)\n        external\n        employeeExists(_employee)\n        returns (bool)\n    {\n        require(isPaymentDue(_employee), \"Payment not due yet\");\n\n        uint256 paymentAmount = calculatePaymentAmount(_employee);\n        require(address(this).balance >= paymentAmount, \"Insufficient balance\");\n\n        _processPayment(_employee, paymentAmount);\n        return true;\n    }\n\n    /**\n     * @notice Internal function to process payment\n     * @param _employee Employee address\n     * @param _amount Payment amount\n     */\n    function _processPayment(address _employee, uint256 _amount) internal {\n        Employee storage emp = employees[_employee];\n\n        emp.lastPaymentTime = block.timestamp;\n        emp.totalPaid += _amount;\n        totalPayrollCost += _amount;\n\n        paymentHistory.push(PaymentRecord({\n            employee: _employee,\n            amount: _amount,\n            timestamp: block.timestamp,\n            paymentId: paymentHistory.length\n        }));\n\n        (bool success, ) = _employee.call{value: _amount}(\"\");\n        require(success, \"Payment failed\");\n\n        emit PaymentProcessed(_employee, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice Check if payment is due for an employee\n     * @param _employee Employee address\n     * @return bool Payment due status\n     */\n    function isPaymentDue(address _employee) public view returns (bool) {\n        Employee memory emp = employees[_employee];\n\n        if (!emp.active) return false;\n        if (emp.lastPaymentTime == 0) return true;\n\n        uint256 timeElapsed = block.timestamp - emp.lastPaymentTime;\n        uint256 paymentInterval = getPaymentInterval(emp.frequency);\n\n        return timeElapsed >= paymentInterval;\n    }\n\n    /**\n     * @notice Calculate payment amount based on frequency\n     * @param _employee Employee address\n     * @return amount Payment amount\n     */\n    function calculatePaymentAmount(address _employee) public view returns (uint256) {\n        Employee memory emp = employees[_employee];\n\n        if (emp.frequency == PaymentFrequency.WEEKLY) {\n            return emp.salary / 52; // Weekly\n        } else if (emp.frequency == PaymentFrequency.BIWEEKLY) {\n            return emp.salary / 26; // Bi-weekly\n        } else if (emp.frequency == PaymentFrequency.MONTHLY) {\n            return emp.salary / 12; // Monthly\n        } else {\n            return emp.salary / 4; // Quarterly\n        }\n    }\n\n    /**\n     * @notice Get payment interval in seconds\n     * @param _frequency Payment frequency\n     * @return interval Interval in seconds\n     */\n    function getPaymentInterval(PaymentFrequency _frequency) public pure returns (uint256) {\n        if (_frequency == PaymentFrequency.WEEKLY) {\n            return 7 days;\n        } else if (_frequency == PaymentFrequency.BIWEEKLY) {\n            return 14 days;\n        } else if (_frequency == PaymentFrequency.MONTHLY) {\n            return 30 days;\n        } else {\n            return 90 days;\n        }\n    }\n\n    /**\n     * @notice Get employee details\n     * @param _employee Employee address\n     * @return name Employee name\n     * @return salary Employee salary\n     * @return frequency Payment frequency\n     * @return lastPaymentTime Last payment timestamp\n     * @return totalPaid Total amount paid\n     * @return active Employee active status\n     */\n    function getEmployeeDetails(address _employee)\n        external\n        view\n        returns (\n            string memory name,\n            uint256 salary,\n            PaymentFrequency frequency,\n            uint256 lastPaymentTime,\n            uint256 totalPaid,\n            bool active\n        )\n    {\n        Employee memory emp = employees[_employee];\n        return (\n            emp.name,\n            emp.salary,\n            emp.frequency,\n            emp.lastPaymentTime,\n            emp.totalPaid,\n            emp.active\n        );\n    }\n\n    /**\n     * @notice Get total active payroll cost (annual)\n     * @return cost Total annual payroll cost\n     */\n    function getTotalActivePayrollCost() external view returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i < employeeList.length; i++) {\n            if (employees[employeeList[i]].active) {\n                total += employees[employeeList[i]].salary;\n            }\n        }\n        return total;\n    }\n\n    /**\n     * @notice Get payment history count\n     * @return count Number of payments\n     */\n    function getPaymentHistoryCount() external view returns (uint256) {\n        return paymentHistory.length;\n    }\n\n    /**\n     * @notice Get all active employees\n     * @return addresses Array of active employee addresses\n     */\n    function getActiveEmployees() external view returns (address[] memory) {\n        address[] memory active = new address[](activeEmployees);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < employeeList.length; i++) {\n            if (employees[employeeList[i]].active) {\n                active[index] = employeeList[i];\n                index++;\n            }\n        }\n\n        return active;\n    }\n\n    /**\n     * @notice Receive funds from treasury\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Change admin\n     * @param _newAdmin New admin address\n     */\n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Invalid admin\");\n        address oldAdmin = admin;\n        admin = _newAdmin;\n        emit AdminChanged(oldAdmin, _newAdmin);\n    }\n\n    /**\n     * @notice Get USDC balance of this contract\n     * @return balance Current USDC balance\n     */\n    function getBalance() external view returns (uint256) {\n        return usdc.balanceOf(address(this));\n    }\n\n    /**\n     * @notice Get total payments made to all employees\n     * @return total Total amount paid out\n     */\n    function totalPaymentsMade() external view returns (uint256) {\n        return totalPayrollCost;\n    }\n\n    /**\n     * @notice Calculate next payment time for an employee\n     * @param employeeIndex Index in employeeList\n     * @return nextPayment Time of next payment\n     */\n    function getNextPaymentTime(uint256 employeeIndex) external view returns (uint256) {\n        require(employeeIndex < employeeList.length, \"Invalid index\");\n\n        address empAddr = employeeList[employeeIndex];\n        Employee storage emp = employees[empAddr];\n\n        if (!emp.active || emp.lastPaymentTime == 0) {\n            return block.timestamp;\n        }\n\n        uint256 interval;\n        if (emp.frequency == PaymentFrequency.WEEKLY) {\n            interval = 7 days;\n        } else if (emp.frequency == PaymentFrequency.BIWEEKLY) {\n            interval = 14 days;\n        } else if (emp.frequency == PaymentFrequency.MONTHLY) {\n            interval = 30 days;\n        } else {\n            interval = 90 days;\n        }\n\n        return emp.lastPaymentTime + interval;\n    }\n}\n"
    },
    "contracts/RuleEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./TreasuryCore.sol\";\n\n/**\n * @title RuleEngine\n * @notice Automated rule-based distribution system for treasury management\n * @dev Allows creation of rules that automatically distribute funds based on conditions\n */\ncontract RuleEngine is AccessControl, Pausable, ReentrancyGuard {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    enum RuleType {\n        THRESHOLD,      // Trigger when balance exceeds threshold\n        PERCENTAGE,     // Distribute percentage of balance\n        SCHEDULED,      // Execute at specific intervals\n        HYBRID          // Combination of conditions\n    }\n\n    enum RuleStatus {\n        ACTIVE,\n        PAUSED,\n        DISABLED\n    }\n\n    struct Rule {\n        uint256 id;\n        string name;\n        string description;\n        RuleType ruleType;\n        RuleStatus status;\n\n        // Conditions\n        uint256 triggerAmount;      // Minimum balance to trigger\n        uint256 checkInterval;      // Seconds between checks\n        uint256 minExecutionGap;    // Min time between executions\n\n        // Actions\n        address[] recipients;       // Where to send funds\n        uint256[] amounts;          // Fixed amounts OR\n        uint256[] percentages;      // Percentages (in basis points, 100 = 1%)\n        bool usePercentages;        // True for percentages, false for fixed amounts\n        uint256 maxPerExecution;    // Max to distribute per execution\n\n        // Metadata\n        uint256 createdAt;\n        uint256 lastExecuted;\n        uint256 timesExecuted;\n        uint256 totalDistributed;\n        address creator;\n    }\n\n    TreasuryCore public treasury;\n    IERC20 public usdc;\n\n    uint256 public ruleCount;\n    mapping(uint256 => Rule) public rules;\n    mapping(uint256 => bool) public ruleExists;\n\n    // Events\n    event RuleCreated(\n        uint256 indexed ruleId,\n        string name,\n        RuleType ruleType,\n        address indexed creator\n    );\n\n    event RuleExecuted(\n        uint256 indexed ruleId,\n        uint256 totalAmount,\n        uint256 recipientCount,\n        uint256 timestamp\n    );\n\n    event RuleStatusChanged(\n        uint256 indexed ruleId,\n        RuleStatus oldStatus,\n        RuleStatus newStatus\n    );\n\n    event RuleUpdated(uint256 indexed ruleId);\n    event RuleDeleted(uint256 indexed ruleId);\n\n    event DistributionFailed(\n        uint256 indexed ruleId,\n        address indexed recipient,\n        uint256 amount,\n        string reason\n    );\n\n    constructor(address _treasury, address _usdc) {\n        require(_treasury != address(0), \"Invalid treasury address\");\n        require(_usdc != address(0), \"Invalid USDC address\");\n\n        treasury = TreasuryCore(payable(_treasury));\n        usdc = IERC20(_usdc);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n        _grantRole(OPERATOR_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Create a new distribution rule\n     * @param name Rule name\n     * @param description Rule description\n     * @param ruleType Type of rule (THRESHOLD, PERCENTAGE, etc.)\n     * @param triggerAmount Minimum balance to trigger rule\n     * @param checkInterval Seconds between rule evaluations\n     * @param minExecutionGap Minimum seconds between executions\n     * @param recipients Array of recipient addresses\n     * @param values Array of amounts or percentages\n     * @param usePercentages True if values are percentages, false if fixed amounts\n     * @param maxPerExecution Maximum amount to distribute per execution\n     */\n    function createRule(\n        string memory name,\n        string memory description,\n        RuleType ruleType,\n        uint256 triggerAmount,\n        uint256 checkInterval,\n        uint256 minExecutionGap,\n        address[] memory recipients,\n        uint256[] memory values,\n        bool usePercentages,\n        uint256 maxPerExecution\n    ) external onlyRole(ADMIN_ROLE) returns (uint256) {\n        require(bytes(name).length > 0, \"Name required\");\n        require(recipients.length > 0, \"No recipients\");\n        require(recipients.length == values.length, \"Length mismatch\");\n        require(checkInterval > 0, \"Invalid interval\");\n\n        // Validate percentages sum to 10000 (100%) if using percentages\n        if (usePercentages) {\n            uint256 totalPercentage = 0;\n            for (uint256 i = 0; i < values.length; i++) {\n                totalPercentage += values[i];\n            }\n            require(totalPercentage <= 10000, \"Percentages exceed 100%\");\n        }\n\n        uint256 ruleId = ruleCount++;\n\n        Rule storage newRule = rules[ruleId];\n        newRule.id = ruleId;\n        newRule.name = name;\n        newRule.description = description;\n        newRule.ruleType = ruleType;\n        newRule.status = RuleStatus.ACTIVE;\n        newRule.triggerAmount = triggerAmount;\n        newRule.checkInterval = checkInterval;\n        newRule.minExecutionGap = minExecutionGap;\n        newRule.recipients = recipients;\n        newRule.usePercentages = usePercentages;\n        newRule.maxPerExecution = maxPerExecution;\n        newRule.createdAt = block.timestamp;\n        newRule.creator = msg.sender;\n\n        if (usePercentages) {\n            newRule.percentages = values;\n        } else {\n            newRule.amounts = values;\n        }\n\n        ruleExists[ruleId] = true;\n\n        emit RuleCreated(ruleId, name, ruleType, msg.sender);\n\n        return ruleId;\n    }\n\n    /**\n     * @notice Evaluate if a rule should be executed\n     * @param ruleId Rule identifier\n     * @return shouldExecute True if rule conditions are met\n     * @return reason Human-readable reason\n     */\n    function evaluateRule(uint256 ruleId) public view returns (bool shouldExecute, string memory reason) {\n        require(ruleExists[ruleId], \"Rule does not exist\");\n\n        Rule storage rule = rules[ruleId];\n\n        // Check if rule is active\n        if (rule.status != RuleStatus.ACTIVE) {\n            return (false, \"Rule is not active\");\n        }\n\n        // Check minimum execution gap\n        if (rule.lastExecuted > 0 && block.timestamp < rule.lastExecuted + rule.minExecutionGap) {\n            return (false, \"Execution gap not met\");\n        }\n\n        // Check treasury balance\n        uint256 balance = treasury.getBalance();\n        if (balance < rule.triggerAmount) {\n            return (false, \"Balance below trigger amount\");\n        }\n\n        // Check if enough time has passed since last check\n        if (rule.ruleType == RuleType.SCHEDULED) {\n            if (rule.lastExecuted > 0 && block.timestamp < rule.lastExecuted + rule.checkInterval) {\n                return (false, \"Schedule interval not reached\");\n            }\n        }\n\n        return (true, \"Rule conditions met\");\n    }\n\n    /**\n     * @notice Execute a rule's distribution\n     * @param ruleId Rule identifier\n     */\n    function executeRule(uint256 ruleId) external nonReentrant whenNotPaused onlyRole(OPERATOR_ROLE) {\n        require(ruleExists[ruleId], \"Rule does not exist\");\n\n        (bool shouldExecute, string memory reason) = evaluateRule(ruleId);\n        require(shouldExecute, reason);\n\n        Rule storage rule = rules[ruleId];\n        uint256 balance = treasury.getBalance();\n        uint256 totalToDistribute = 0;\n\n        // Calculate distribution amounts\n        uint256[] memory distributionAmounts = new uint256[](rule.recipients.length);\n\n        if (rule.usePercentages) {\n            // Calculate percentage-based distributions\n            for (uint256 i = 0; i < rule.recipients.length; i++) {\n                uint256 amount = (balance * rule.percentages[i]) / 10000;\n                distributionAmounts[i] = amount;\n                totalToDistribute += amount;\n            }\n        } else {\n            // Use fixed amounts\n            for (uint256 i = 0; i < rule.recipients.length; i++) {\n                distributionAmounts[i] = rule.amounts[i];\n                totalToDistribute += rule.amounts[i];\n            }\n        }\n\n        // Apply max per execution limit\n        if (rule.maxPerExecution > 0 && totalToDistribute > rule.maxPerExecution) {\n            // Scale down proportionally\n            for (uint256 i = 0; i < distributionAmounts.length; i++) {\n                distributionAmounts[i] = (distributionAmounts[i] * rule.maxPerExecution) / totalToDistribute;\n            }\n            totalToDistribute = rule.maxPerExecution;\n        }\n\n        // Ensure treasury has enough balance\n        require(balance >= totalToDistribute, \"Insufficient treasury balance\");\n\n        // Execute distributions via treasury\n        for (uint256 i = 0; i < rule.recipients.length; i++) {\n            if (distributionAmounts[i] > 0) {\n                try treasury.proposeTransaction(rule.recipients[i], distributionAmounts[i], \"\") {\n                    // Transaction proposed successfully\n                    // Note: In production, this would need multi-sig approval\n                } catch Error(string memory errorReason) {\n                    emit DistributionFailed(ruleId, rule.recipients[i], distributionAmounts[i], errorReason);\n                } catch {\n                    emit DistributionFailed(ruleId, rule.recipients[i], distributionAmounts[i], \"Unknown error\");\n                }\n            }\n        }\n\n        // Update rule execution metadata\n        rule.lastExecuted = block.timestamp;\n        rule.timesExecuted++;\n        rule.totalDistributed += totalToDistribute;\n\n        emit RuleExecuted(ruleId, totalToDistribute, rule.recipients.length, block.timestamp);\n    }\n\n    /**\n     * @notice Update rule status (ACTIVE, PAUSED, DISABLED)\n     * @param ruleId Rule identifier\n     * @param newStatus New status\n     */\n    function updateRuleStatus(uint256 ruleId, RuleStatus newStatus) external onlyRole(ADMIN_ROLE) {\n        require(ruleExists[ruleId], \"Rule does not exist\");\n\n        Rule storage rule = rules[ruleId];\n        RuleStatus oldStatus = rule.status;\n        rule.status = newStatus;\n\n        emit RuleStatusChanged(ruleId, oldStatus, newStatus);\n    }\n\n    /**\n     * @notice Delete a rule\n     * @param ruleId Rule identifier\n     */\n    function deleteRule(uint256 ruleId) external onlyRole(ADMIN_ROLE) {\n        require(ruleExists[ruleId], \"Rule does not exist\");\n\n        delete rules[ruleId];\n        ruleExists[ruleId] = false;\n\n        emit RuleDeleted(ruleId);\n    }\n\n    /**\n     * @notice Get rule details\n     * @param ruleId Rule identifier\n     */\n    function getRule(uint256 ruleId) external view returns (\n        string memory name,\n        string memory description,\n        RuleType ruleType,\n        RuleStatus status,\n        uint256 triggerAmount,\n        uint256 timesExecuted,\n        uint256 totalDistributed,\n        uint256 lastExecuted\n    ) {\n        require(ruleExists[ruleId], \"Rule does not exist\");\n\n        Rule storage rule = rules[ruleId];\n        return (\n            rule.name,\n            rule.description,\n            rule.ruleType,\n            rule.status,\n            rule.triggerAmount,\n            rule.timesExecuted,\n            rule.totalDistributed,\n            rule.lastExecuted\n        );\n    }\n\n    /**\n     * @notice Get rule recipients and amounts\n     * @param ruleId Rule identifier\n     */\n    function getRuleDistribution(uint256 ruleId) external view returns (\n        address[] memory recipients,\n        uint256[] memory values,\n        bool usePercentages\n    ) {\n        require(ruleExists[ruleId], \"Rule does not exist\");\n\n        Rule storage rule = rules[ruleId];\n        return (\n            rule.recipients,\n            rule.usePercentages ? rule.percentages : rule.amounts,\n            rule.usePercentages\n        );\n    }\n\n    /**\n     * @notice Get all active rules\n     */\n    function getActiveRules() external view returns (uint256[] memory) {\n        uint256 activeCount = 0;\n\n        // Count active rules\n        for (uint256 i = 0; i < ruleCount; i++) {\n            if (ruleExists[i] && rules[i].status == RuleStatus.ACTIVE) {\n                activeCount++;\n            }\n        }\n\n        // Collect active rule IDs\n        uint256[] memory activeRules = new uint256[](activeCount);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < ruleCount; i++) {\n            if (ruleExists[i] && rules[i].status == RuleStatus.ACTIVE) {\n                activeRules[index] = i;\n                index++;\n            }\n        }\n\n        return activeRules;\n    }\n\n    /**\n     * @notice Pause contract (emergency)\n     */\n    function pause() external onlyRole(ADMIN_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause contract\n     */\n    function unpause() external onlyRole(ADMIN_ROLE) {\n        _unpause();\n    }\n}\n"
    },
    "contracts/ScheduledPayments.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./interfaces/IERC20.sol\";\n\n/**\n * @title ScheduledPayments\n * @notice Automated scheduled payment system for treasury operations\n * @dev Handles one-time and recurring payments with time-based execution\n */\ncontract ScheduledPayments {\n    // Enums\n    enum PaymentStatus {\n        PENDING,\n        EXECUTED,\n        CANCELLED,\n        FAILED\n    }\n\n    // Structs\n    struct ScheduledPayment {\n        uint256 id;\n        address recipient;\n        uint256 amount;\n        uint256 executeAt;\n        bool recurring;\n        uint256 interval; // For recurring payments (in seconds)\n        uint256 executionCount;\n        uint256 maxExecutions; // 0 = unlimited\n        PaymentStatus status;\n        address creator;\n        uint256 createdAt;\n        uint256 lastExecutedAt;\n        string description;\n    }\n\n    // State variables\n    address public treasury;\n    address public admin;\n    IERC20 public usdc;\n\n    mapping(uint256 => ScheduledPayment) public payments;\n    uint256 public paymentCount;\n\n    uint256[] public pendingPayments;\n    mapping(uint256 => bool) public isPending;\n\n    // Events\n    event PaymentScheduled(\n        uint256 indexed paymentId,\n        address indexed recipient,\n        uint256 amount,\n        uint256 executeAt,\n        bool recurring\n    );\n    event PaymentExecuted(uint256 indexed paymentId, uint256 amount, uint256 timestamp);\n    event PaymentCancelled(uint256 indexed paymentId, address indexed canceller);\n    event PaymentFailed(uint256 indexed paymentId, string reason);\n    event RecurringPaymentCompleted(uint256 indexed paymentId, uint256 totalExecutions);\n\n    // Modifiers\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin can call\");\n        _;\n    }\n\n    modifier onlyTreasury() {\n        require(msg.sender == treasury, \"Only treasury can call\");\n        _;\n    }\n\n    modifier paymentExists(uint256 _paymentId) {\n        require(_paymentId < paymentCount, \"Payment does not exist\");\n        _;\n    }\n\n    /**\n     * @notice Initialize scheduled payments\n     * @param _treasury Treasury contract address\n     * @param _usdc USDC token address\n     */\n    constructor(address _treasury, address _usdc) {\n        require(_treasury != address(0), \"Invalid treasury\");\n        require(_usdc != address(0), \"Invalid USDC address\");\n\n        treasury = _treasury;\n        admin = msg.sender;\n        usdc = IERC20(_usdc);\n    }\n\n    /**\n     * @notice Schedule a new payment\n     * @param _recipient Payment recipient\n     * @param _amount Payment amount\n     * @param _executeAt Execution timestamp\n     * @param _recurring Whether payment is recurring\n     * @param _interval Interval for recurring payments (seconds)\n     * @param _maxExecutions Maximum executions (0 = unlimited)\n     * @param _description Payment description\n     * @return paymentId Payment ID\n     */\n    function schedulePayment(\n        address _recipient,\n        uint256 _amount,\n        uint256 _executeAt,\n        bool _recurring,\n        uint256 _interval,\n        uint256 _maxExecutions,\n        string memory _description\n    ) external onlyAdmin returns (uint256) {\n        require(_recipient != address(0), \"Invalid recipient\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(_executeAt > block.timestamp, \"Execution time must be in future\");\n\n        if (_recurring) {\n            require(_interval > 0, \"Interval required for recurring payments\");\n        }\n\n        uint256 paymentId = paymentCount;\n\n        payments[paymentId] = ScheduledPayment({\n            id: paymentId,\n            recipient: _recipient,\n            amount: _amount,\n            executeAt: _executeAt,\n            recurring: _recurring,\n            interval: _interval,\n            executionCount: 0,\n            maxExecutions: _maxExecutions,\n            status: PaymentStatus.PENDING,\n            creator: msg.sender,\n            createdAt: block.timestamp,\n            lastExecutedAt: 0,\n            description: _description\n        });\n\n        pendingPayments.push(paymentId);\n        isPending[paymentId] = true;\n\n        paymentCount++;\n\n        emit PaymentScheduled(paymentId, _recipient, _amount, _executeAt, _recurring);\n\n        return paymentId;\n    }\n\n    /**\n     * @notice Execute a scheduled payment\n     * @param _paymentId Payment ID\n     */\n    function executeScheduledPayment(uint256 _paymentId)\n        external\n        paymentExists(_paymentId)\n        returns (bool)\n    {\n        ScheduledPayment storage payment = payments[_paymentId];\n\n        require(payment.status == PaymentStatus.PENDING, \"Payment not pending\");\n        require(block.timestamp >= payment.executeAt, \"Payment not due yet\");\n        require(address(this).balance >= payment.amount, \"Insufficient balance\");\n\n        // Check if max executions reached\n        if (payment.maxExecutions > 0 && payment.executionCount >= payment.maxExecutions) {\n            payment.status = PaymentStatus.EXECUTED;\n            _removePendingPayment(_paymentId);\n            emit RecurringPaymentCompleted(_paymentId, payment.executionCount);\n            return false;\n        }\n\n        // Execute payment\n        (bool success, ) = payment.recipient.call{value: payment.amount}(\"\");\n\n        if (!success) {\n            emit PaymentFailed(_paymentId, \"Transfer failed\");\n            return false;\n        }\n\n        payment.executionCount++;\n        payment.lastExecutedAt = block.timestamp;\n\n        emit PaymentExecuted(_paymentId, payment.amount, block.timestamp);\n\n        // Handle recurring payment\n        if (payment.recurring) {\n            payment.executeAt = block.timestamp + payment.interval;\n\n            // Check if max executions reached\n            if (payment.maxExecutions > 0 && payment.executionCount >= payment.maxExecutions) {\n                payment.status = PaymentStatus.EXECUTED;\n                _removePendingPayment(_paymentId);\n                emit RecurringPaymentCompleted(_paymentId, payment.executionCount);\n            }\n        } else {\n            payment.status = PaymentStatus.EXECUTED;\n            _removePendingPayment(_paymentId);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Execute all due payments\n     * @return executed Number of payments executed\n     */\n    function executeAllDuePayments() external returns (uint256 executed) {\n        uint256 count = 0;\n\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\n            uint256 paymentId = pendingPayments[i];\n            ScheduledPayment storage payment = payments[paymentId];\n\n            if (\n                payment.status == PaymentStatus.PENDING &&\n                block.timestamp >= payment.executeAt &&\n                address(this).balance >= payment.amount\n            ) {\n                if (this.executeScheduledPayment(paymentId)) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    /**\n     * @notice Cancel a scheduled payment\n     * @param _paymentId Payment ID\n     */\n    function cancelScheduledPayment(uint256 _paymentId)\n        external\n        onlyAdmin\n        paymentExists(_paymentId)\n    {\n        ScheduledPayment storage payment = payments[_paymentId];\n        require(payment.status == PaymentStatus.PENDING, \"Payment not pending\");\n\n        payment.status = PaymentStatus.CANCELLED;\n        _removePendingPayment(_paymentId);\n\n        emit PaymentCancelled(_paymentId, msg.sender);\n    }\n\n    /**\n     * @notice Remove payment from pending list\n     * @param _paymentId Payment ID\n     */\n    function _removePendingPayment(uint256 _paymentId) internal {\n        if (!isPending[_paymentId]) return;\n\n        isPending[_paymentId] = false;\n\n        // Find and remove from array\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\n            if (pendingPayments[i] == _paymentId) {\n                pendingPayments[i] = pendingPayments[pendingPayments.length - 1];\n                pendingPayments.pop();\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Get upcoming payments (next 7 days)\n     * @return upcomingIds Array of upcoming payment IDs\n     */\n    function getUpcomingPayments() external view returns (uint256[] memory) {\n        uint256 weekFromNow = block.timestamp + 7 days;\n        uint256 upcomingCount = 0;\n\n        // Count upcoming payments\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\n            uint256 paymentId = pendingPayments[i];\n            if (payments[paymentId].executeAt <= weekFromNow) {\n                upcomingCount++;\n            }\n        }\n\n        // Populate array\n        uint256[] memory upcoming = new uint256[](upcomingCount);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\n            uint256 paymentId = pendingPayments[i];\n            if (payments[paymentId].executeAt <= weekFromNow) {\n                upcoming[index] = paymentId;\n                index++;\n            }\n        }\n\n        return upcoming;\n    }\n\n    /**\n     * @notice Get due payments\n     * @return dueIds Array of due payment IDs\n     */\n    function getDuePayments() external view returns (uint256[] memory) {\n        uint256 dueCount = 0;\n\n        // Count due payments\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\n            uint256 paymentId = pendingPayments[i];\n            if (\n                payments[paymentId].status == PaymentStatus.PENDING &&\n                block.timestamp >= payments[paymentId].executeAt\n            ) {\n                dueCount++;\n            }\n        }\n\n        // Populate array\n        uint256[] memory due = new uint256[](dueCount);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\n            uint256 paymentId = pendingPayments[i];\n            if (\n                payments[paymentId].status == PaymentStatus.PENDING &&\n                block.timestamp >= payments[paymentId].executeAt\n            ) {\n                due[index] = paymentId;\n                index++;\n            }\n        }\n\n        return due;\n    }\n\n    /**\n     * @notice Get payment details\n     * @param _paymentId Payment ID\n     * @return recipient Payment recipient\n     * @return amount Payment amount\n     * @return executeAt Execution timestamp\n     * @return recurring Recurring status\n     * @return executionCount Number of executions\n     * @return status Payment status\n     * @return description Payment description\n     */\n    function getPaymentDetails(uint256 _paymentId)\n        external\n        view\n        paymentExists(_paymentId)\n        returns (\n            address recipient,\n            uint256 amount,\n            uint256 executeAt,\n            bool recurring,\n            uint256 executionCount,\n            PaymentStatus status,\n            string memory description\n        )\n    {\n        ScheduledPayment memory payment = payments[_paymentId];\n        return (\n            payment.recipient,\n            payment.amount,\n            payment.executeAt,\n            payment.recurring,\n            payment.executionCount,\n            payment.status,\n            payment.description\n        );\n    }\n\n    /**\n     * @notice Get all pending payment IDs\n     * @return Array of pending payment IDs\n     */\n    function getPendingPaymentIds() external view returns (uint256[] memory) {\n        return pendingPayments;\n    }\n\n    /**\n     * @notice Check if payment is due\n     * @param _paymentId Payment ID\n     * @return bool Payment due status\n     */\n    function isPaymentDue(uint256 _paymentId)\n        external\n        view\n        paymentExists(_paymentId)\n        returns (bool)\n    {\n        ScheduledPayment memory payment = payments[_paymentId];\n        return (\n            payment.status == PaymentStatus.PENDING &&\n            block.timestamp >= payment.executeAt\n        );\n    }\n\n    /**\n     * @notice Get total pending payment amount\n     * @return total Total pending amount\n     */\n    function getTotalPendingAmount() external view returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\n            total += payments[pendingPayments[i]].amount;\n        }\n        return total;\n    }\n\n    /**\n     * @notice Receive funds from treasury\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Get USDC balance of this contract\n     * @return balance Current USDC balance\n     */\n    function getBalance() external view returns (uint256) {\n        return usdc.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/TreasuryAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"./TreasuryCore.sol\";\nimport \"./PayrollManager.sol\";\nimport \"./BudgetAllocator.sol\";\nimport \"./ScheduledPayments.sol\";\n\n/**\n * @title TreasuryAggregatorSimple\n * @notice Simplified unified view for MVP\n */\ncontract TreasuryAggregatorSimple {\n    TreasuryCore public treasuryCore;\n    PayrollManager public payrollManager;\n    BudgetAllocator public budgetAllocator;\n    ScheduledPayments public scheduledPayments;\n\n    struct TreasurySnapshot {\n        uint256 totalBalance;\n        uint256 treasuryBalance;\n        uint256 payrollBalance;\n        uint256 budgetBalance;\n        uint256 scheduledBalance;\n        uint256 timestamp;\n    }\n\n    constructor(\n        address _treasuryCore,\n        address _payrollManager,\n        address _budgetAllocator,\n        address _scheduledPayments\n    ) {\n        treasuryCore = TreasuryCore(payable(_treasuryCore));\n        payrollManager = PayrollManager(payable(_payrollManager));\n        budgetAllocator = BudgetAllocator(payable(_budgetAllocator));\n        scheduledPayments = ScheduledPayments(payable(_scheduledPayments));\n    }\n\n    function getTreasurySnapshot() external view returns (TreasurySnapshot memory) {\n        uint256 treasuryBal = treasuryCore.getBalance();\n        uint256 payrollBal = payrollManager.getBalance();\n        uint256 budgetBal = budgetAllocator.getBalance();\n        uint256 scheduledBal = scheduledPayments.getBalance();\n\n        return TreasurySnapshot({\n            totalBalance: treasuryBal + payrollBal + budgetBal + scheduledBal,\n            treasuryBalance: treasuryBal,\n            payrollBalance: payrollBal,\n            budgetBalance: budgetBal,\n            scheduledBalance: scheduledBal,\n            timestamp: block.timestamp\n        });\n    }\n\n    function getBasicStats() external view returns (\n        uint256 totalEmployees,\n        uint256 totalDepartments,\n        uint256 totalScheduledPayments,\n        uint256 totalTransactions\n    ) {\n        return (\n            payrollManager.totalEmployees(),\n            budgetAllocator.departmentCount(),\n            scheduledPayments.paymentCount(),\n            treasuryCore.transactionCount()\n        );\n    }\n}\n"
    },
    "contracts/TreasuryCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/**\n * @title TreasuryCore\n * @notice Core treasury management contract with multi-signature functionality\n * @dev Manages treasury funds, proposals, and multi-sig approvals\n */\ncontract TreasuryCore {\n    // Events\n    event FundsDeposited(address indexed from, uint256 amount, uint256 timestamp);\n    event TransactionProposed(uint256 indexed txId, address indexed proposer, address to, uint256 amount);\n    event TransactionApproved(uint256 indexed txId, address indexed approver);\n    event TransactionExecuted(uint256 indexed txId, address indexed executor);\n    event TransactionCancelled(uint256 indexed txId, address indexed canceller);\n    event OwnerAdded(address indexed owner);\n    event OwnerRemoved(address indexed owner);\n    event ThresholdChanged(uint256 newThreshold);\n    event Paused(address indexed by);\n    event Unpaused(address indexed by);\n\n    // Structs\n    struct Transaction {\n        address to;\n        uint256 amount;\n        bytes data;\n        bool executed;\n        bool cancelled;\n        uint256 approvalCount;\n        uint256 proposedAt;\n        address proposer;\n    }\n\n    // State variables\n    mapping(address => bool) public isOwner;\n    address[] public owners;\n    uint256 public threshold;\n\n    Transaction[] public transactions;\n    mapping(uint256 => mapping(address => bool)) public hasApproved;\n\n    bool public paused;\n\n    // Modifiers\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], \"Not an owner\");\n        _;\n    }\n\n    modifier txExists(uint256 _txId) {\n        require(_txId < transactions.length, \"Transaction does not exist\");\n        _;\n    }\n\n    modifier notExecuted(uint256 _txId) {\n        require(!transactions[_txId].executed, \"Transaction already executed\");\n        _;\n    }\n\n    modifier notCancelled(uint256 _txId) {\n        require(!transactions[_txId].cancelled, \"Transaction cancelled\");\n        _;\n    }\n\n    modifier notApproved(uint256 _txId) {\n        require(!hasApproved[_txId][msg.sender], \"Transaction already approved\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    modifier whenPaused() {\n        require(paused, \"Contract is not paused\");\n        _;\n    }\n\n    /**\n     * @notice Initialize the treasury with owners and approval threshold\n     * @param _owners Array of owner addresses\n     * @param _threshold Number of approvals required for execution\n     */\n    constructor(address[] memory _owners, uint256 _threshold) {\n        require(_owners.length > 0, \"Owners required\");\n        require(_threshold > 0 && _threshold <= _owners.length, \"Invalid threshold\");\n\n        for (uint256 i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n            require(owner != address(0), \"Invalid owner\");\n            require(!isOwner[owner], \"Duplicate owner\");\n\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n\n        threshold = _threshold;\n    }\n\n    /**\n     * @notice Receive USDC deposits\n     */\n    receive() external payable {\n        emit FundsDeposited(msg.sender, msg.value, block.timestamp);\n    }\n\n    /**\n     * @notice Get the current treasury balance\n     * @return balance Current balance in wei\n     */\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @notice Propose a new transaction\n     * @param _to Recipient address\n     * @param _amount Amount to send\n     * @param _data Additional data for the transaction\n     * @return txId Transaction ID\n     */\n    function proposeTransaction(\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) external onlyOwner whenNotPaused returns (uint256) {\n        require(_to != address(0), \"Invalid recipient\");\n\n        uint256 txId = transactions.length;\n\n        transactions.push(Transaction({\n            to: _to,\n            amount: _amount,\n            data: _data,\n            executed: false,\n            cancelled: false,\n            approvalCount: 0,\n            proposedAt: block.timestamp,\n            proposer: msg.sender\n        }));\n\n        emit TransactionProposed(txId, msg.sender, _to, _amount);\n\n        return txId;\n    }\n\n    /**\n     * @notice Approve a proposed transaction\n     * @param _txId Transaction ID to approve\n     */\n    function approveTransaction(uint256 _txId)\n        external\n        onlyOwner\n        txExists(_txId)\n        notExecuted(_txId)\n        notCancelled(_txId)\n        notApproved(_txId)\n        whenNotPaused\n    {\n        hasApproved[_txId][msg.sender] = true;\n        transactions[_txId].approvalCount += 1;\n\n        emit TransactionApproved(_txId, msg.sender);\n    }\n\n    /**\n     * @notice Execute an approved transaction\n     * @param _txId Transaction ID to execute\n     */\n    function executeTransaction(uint256 _txId)\n        external\n        onlyOwner\n        txExists(_txId)\n        notExecuted(_txId)\n        notCancelled(_txId)\n        whenNotPaused\n    {\n        Transaction storage txn = transactions[_txId];\n\n        require(txn.approvalCount >= threshold, \"Insufficient approvals\");\n        require(address(this).balance >= txn.amount, \"Insufficient balance\");\n\n        txn.executed = true;\n\n        (bool success, ) = txn.to.call{value: txn.amount}(txn.data);\n        require(success, \"Transaction execution failed\");\n\n        emit TransactionExecuted(_txId, msg.sender);\n    }\n\n    /**\n     * @notice Cancel a proposed transaction\n     * @param _txId Transaction ID to cancel\n     */\n    function cancelTransaction(uint256 _txId)\n        external\n        onlyOwner\n        txExists(_txId)\n        notExecuted(_txId)\n        notCancelled(_txId)\n    {\n        Transaction storage txn = transactions[_txId];\n        require(txn.proposer == msg.sender, \"Only proposer can cancel\");\n\n        txn.cancelled = true;\n\n        emit TransactionCancelled(_txId, msg.sender);\n    }\n\n    /**\n     * @notice Pause the contract (emergency)\n     */\n    function pause() external onlyOwner whenNotPaused {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause the contract\n     */\n    function unpause() external onlyOwner whenPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @notice Get transaction details\n     * @param _txId Transaction ID\n     * @return to Recipient address\n     * @return amount Transaction amount\n     * @return data Transaction data\n     * @return executed Execution status\n     * @return cancelled Cancellation status\n     * @return approvalCount Number of approvals\n     */\n    function getTransaction(uint256 _txId)\n        external\n        view\n        txExists(_txId)\n        returns (\n            address to,\n            uint256 amount,\n            bytes memory data,\n            bool executed,\n            bool cancelled,\n            uint256 approvalCount\n        )\n    {\n        Transaction memory txn = transactions[_txId];\n        return (\n            txn.to,\n            txn.amount,\n            txn.data,\n            txn.executed,\n            txn.cancelled,\n            txn.approvalCount\n        );\n    }\n\n    /**\n     * @notice Get total number of transactions\n     * @return count Transaction count\n     */\n    function getTransactionCount() external view returns (uint256) {\n        return transactions.length;\n    }\n\n    /**\n     * @notice Get all owners\n     * @return Array of owner addresses\n     */\n    function getOwners() external view returns (address[] memory) {\n        return owners;\n    }\n\n    /**\n     * @notice Check if transaction is approved by an owner\n     * @param _txId Transaction ID\n     * @param _owner Owner address\n     * @return bool Approval status\n     */\n    function isApproved(uint256 _txId, address _owner) external view returns (bool) {\n        return hasApproved[_txId][_owner];\n    }\n\n    /**\n     * @notice Get total number of transactions\n     * @return count Total transactions\n     */\n    function transactionCount() external view returns (uint256) {\n        return transactions.length;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}