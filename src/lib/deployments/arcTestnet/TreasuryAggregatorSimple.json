{
  "address": "0x5ac2081a1C50361458421840053063F6957b2fA5",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_treasuryCore",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_payrollManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_budgetAllocator",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_scheduledPayments",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "budgetAllocator",
      "outputs": [
        {
          "internalType": "contract BudgetAllocator",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBasicStats",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalEmployees",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalDepartments",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalScheduledPayments",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalTransactions",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTreasurySnapshot",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "totalBalance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "treasuryBalance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "payrollBalance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "budgetBalance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "scheduledBalance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            }
          ],
          "internalType": "struct TreasuryAggregatorSimple.TreasurySnapshot",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "payrollManager",
      "outputs": [
        {
          "internalType": "contract PayrollManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "scheduledPayments",
      "outputs": [
        {
          "internalType": "contract ScheduledPayments",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "treasuryCore",
      "outputs": [
        {
          "internalType": "contract TreasuryCore",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x825a8235ecfd7ef3559c75019c1868d4cbbac52748c2db69d8b105d9dd201ae3",
  "receipt": {
    "to": null,
    "from": "0x1484fb70070B7907af809EECc5eAE2ae2cd04C28",
    "contractAddress": "0x5ac2081a1C50361458421840053063F6957b2fA5",
    "transactionIndex": 4,
    "gasUsed": "474770",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x90cb123f8fb7f29616edcd03bfb719e96b7d44bd85a21a0424ab3654997cd35e",
    "transactionHash": "0x825a8235ecfd7ef3559c75019c1868d4cbbac52748c2db69d8b105d9dd201ae3",
    "logs": [],
    "blockNumber": 11287996,
    "cumulativeGasUsed": "2244110",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xcee3Bb02aE95E1Dbc2e5C51a502Ac6eC5deEFa81",
    "0x4D2a7873Ab6CE048532d22f6D9D572E217c5e128",
    "0x1438D8a1866ABe4267187369888562CEC19bCA92",
    "0xc4a1dFE961ea2b5C9cbfAEc4b43278Cc17ecED54"
  ],
  "numDeployments": 1,
  "solcInputHash": "c8cc5f07fcb48433307ce8656020ab61",
  "metadata": "{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasuryCore\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_payrollManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_budgetAllocator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_scheduledPayments\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"budgetAllocator\",\"outputs\":[{\"internalType\":\"contract BudgetAllocator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBasicStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalEmployees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepartments\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalScheduledPayments\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTransactions\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTreasurySnapshot\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"treasuryBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payrollBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"budgetBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scheduledBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct TreasuryAggregatorSimple.TreasurySnapshot\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payrollManager\",\"outputs\":[{\"internalType\":\"contract PayrollManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scheduledPayments\",\"outputs\":[{\"internalType\":\"contract ScheduledPayments\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryCore\",\"outputs\":[{\"internalType\":\"contract TreasuryCore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"TreasuryAggregatorSimple\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Simplified unified view for MVP\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/TreasuryAggregator.sol\":\"TreasuryAggregatorSimple\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"contracts/BudgetAllocator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.30;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\n\\n/**\\n * @title BudgetAllocator\\n * @notice Department budget management and allocation system\\n * @dev Manages department budgets, spending, and fund requests\\n */\\ncontract BudgetAllocator {\\n    // Structs\\n    struct Department {\\n        uint256 id;\\n        string name;\\n        uint256 totalBudget;\\n        uint256 spentAmount;\\n        uint256 availableBalance;\\n        address manager;\\n        bool active;\\n        uint256 createdAt;\\n    }\\n\\n    struct FundRequest {\\n        uint256 id;\\n        uint256 departmentId;\\n        address requester;\\n        uint256 amount;\\n        string reason;\\n        bool approved;\\n        bool rejected;\\n        bool executed;\\n        uint256 requestedAt;\\n        address approvedBy;\\n    }\\n\\n    struct Expense {\\n        uint256 id;\\n        uint256 departmentId;\\n        uint256 amount;\\n        string description;\\n        address spentBy;\\n        uint256 timestamp;\\n    }\\n\\n    // State variables\\n    address public treasury;\\n    address public admin;\\n    IERC20 public usdc;\\n\\n    mapping(uint256 => Department) public departments;\\n    uint256 public departmentCount;\\n\\n    mapping(uint256 => FundRequest) public fundRequests;\\n    uint256 public requestCount;\\n\\n    mapping(uint256 => Expense[]) public departmentExpenses;\\n    Expense[] public allExpenses;\\n\\n    // Events\\n    event DepartmentCreated(uint256 indexed departmentId, string name, uint256 budget, address manager);\\n    event BudgetAllocated(uint256 indexed departmentId, uint256 amount);\\n    event BudgetUpdated(uint256 indexed departmentId, uint256 newBudget);\\n    event FundRequested(uint256 indexed requestId, uint256 indexed departmentId, uint256 amount, string reason);\\n    event RequestApproved(uint256 indexed requestId, address indexed approver);\\n    event RequestRejected(uint256 indexed requestId, address indexed rejector);\\n    event FundsTransferred(uint256 indexed departmentId, address indexed recipient, uint256 amount);\\n    event ExpenseRecorded(uint256 indexed departmentId, uint256 amount, string description);\\n    event DepartmentDeactivated(uint256 indexed departmentId);\\n\\n    // Modifiers\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"Only admin can call\\\");\\n        _;\\n    }\\n\\n    modifier onlyTreasury() {\\n        require(msg.sender == treasury, \\\"Only treasury can call\\\");\\n        _;\\n    }\\n\\n    modifier departmentExists(uint256 _departmentId) {\\n        require(_departmentId < departmentCount, \\\"Department does not exist\\\");\\n        require(departments[_departmentId].active, \\\"Department is inactive\\\");\\n        _;\\n    }\\n\\n    modifier onlyDepartmentManager(uint256 _departmentId) {\\n        require(departments[_departmentId].manager == msg.sender, \\\"Only department manager\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initialize budget allocator\\n     * @param _treasury Treasury contract address\\n     * @param _usdc USDC token address\\n     */\\n    constructor(address _treasury, address _usdc) {\\n        require(_treasury != address(0), \\\"Invalid treasury\\\");\\n        require(_usdc != address(0), \\\"Invalid USDC address\\\");\\n\\n        treasury = _treasury;\\n        admin = msg.sender;\\n        usdc = IERC20(_usdc);\\n    }\\n\\n    /**\\n     * @notice Create a new department\\n     * @param _name Department name\\n     * @param _budget Initial budget allocation\\n     * @param _manager Department manager address\\n     * @return departmentId New department ID\\n     */\\n    function createDepartment(\\n        string memory _name,\\n        uint256 _budget,\\n        address _manager\\n    ) external onlyAdmin returns (uint256) {\\n        require(bytes(_name).length > 0, \\\"Name required\\\");\\n        require(_manager != address(0), \\\"Invalid manager\\\");\\n\\n        uint256 departmentId = departmentCount;\\n\\n        departments[departmentId] = Department({\\n            id: departmentId,\\n            name: _name,\\n            totalBudget: _budget,\\n            spentAmount: 0,\\n            availableBalance: _budget,\\n            manager: _manager,\\n            active: true,\\n            createdAt: block.timestamp\\n        });\\n\\n        departmentCount++;\\n\\n        emit DepartmentCreated(departmentId, _name, _budget, _manager);\\n\\n        return departmentId;\\n    }\\n\\n    /**\\n     * @notice Allocate additional funds to a department\\n     * @param _departmentId Department ID\\n     * @param _amount Amount to allocate\\n     */\\n    function allocateFunds(uint256 _departmentId, uint256 _amount)\\n        external\\n        onlyAdmin\\n        departmentExists(_departmentId)\\n    {\\n        require(_amount > 0, \\\"Amount must be greater than 0\\\");\\n\\n        Department storage dept = departments[_departmentId];\\n        dept.totalBudget += _amount;\\n        dept.availableBalance += _amount;\\n\\n        emit BudgetAllocated(_departmentId, _amount);\\n    }\\n\\n    /**\\n     * @notice Request additional funds for a department\\n     * @param _departmentId Department ID\\n     * @param _amount Amount requested\\n     * @param _reason Reason for request\\n     * @return requestId Fund request ID\\n     */\\n    function requestFunds(\\n        uint256 _departmentId,\\n        uint256 _amount,\\n        string memory _reason\\n    ) external departmentExists(_departmentId) returns (uint256) {\\n        require(_amount > 0, \\\"Amount must be greater than 0\\\");\\n        require(bytes(_reason).length > 0, \\\"Reason required\\\");\\n\\n        uint256 requestId = requestCount;\\n\\n        fundRequests[requestId] = FundRequest({\\n            id: requestId,\\n            departmentId: _departmentId,\\n            requester: msg.sender,\\n            amount: _amount,\\n            reason: _reason,\\n            approved: false,\\n            rejected: false,\\n            executed: false,\\n            requestedAt: block.timestamp,\\n            approvedBy: address(0)\\n        });\\n\\n        requestCount++;\\n\\n        emit FundRequested(requestId, _departmentId, _amount, _reason);\\n\\n        return requestId;\\n    }\\n\\n    /**\\n     * @notice Approve a fund request\\n     * @param _requestId Request ID\\n     */\\n    function approveFundRequest(uint256 _requestId) external onlyAdmin {\\n        require(_requestId < requestCount, \\\"Request does not exist\\\");\\n\\n        FundRequest storage request = fundRequests[_requestId];\\n        require(!request.approved && !request.rejected, \\\"Request already processed\\\");\\n        require(!request.executed, \\\"Request already executed\\\");\\n\\n        request.approved = true;\\n        request.approvedBy = msg.sender;\\n\\n        // Automatically allocate funds\\n        Department storage dept = departments[request.departmentId];\\n        dept.totalBudget += request.amount;\\n        dept.availableBalance += request.amount;\\n\\n        request.executed = true;\\n\\n        emit RequestApproved(_requestId, msg.sender);\\n        emit BudgetAllocated(request.departmentId, request.amount);\\n    }\\n\\n    /**\\n     * @notice Reject a fund request\\n     * @param _requestId Request ID\\n     */\\n    function rejectFundRequest(uint256 _requestId) external onlyAdmin {\\n        require(_requestId < requestCount, \\\"Request does not exist\\\");\\n\\n        FundRequest storage request = fundRequests[_requestId];\\n        require(!request.approved && !request.rejected, \\\"Request already processed\\\");\\n\\n        request.rejected = true;\\n\\n        emit RequestRejected(_requestId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Record an expense for a department\\n     * @param _departmentId Department ID\\n     * @param _amount Expense amount\\n     * @param _description Expense description\\n     */\\n    function recordExpense(\\n        uint256 _departmentId,\\n        uint256 _amount,\\n        string memory _description\\n    ) external departmentExists(_departmentId) onlyDepartmentManager(_departmentId) {\\n        require(_amount > 0, \\\"Amount must be greater than 0\\\");\\n\\n        Department storage dept = departments[_departmentId];\\n        require(dept.availableBalance >= _amount, \\\"Insufficient budget\\\");\\n\\n        dept.spentAmount += _amount;\\n        dept.availableBalance -= _amount;\\n\\n        Expense memory expense = Expense({\\n            id: allExpenses.length,\\n            departmentId: _departmentId,\\n            amount: _amount,\\n            description: _description,\\n            spentBy: msg.sender,\\n            timestamp: block.timestamp\\n        });\\n\\n        departmentExpenses[_departmentId].push(expense);\\n        allExpenses.push(expense);\\n\\n        emit ExpenseRecorded(_departmentId, _amount, _description);\\n    }\\n\\n    /**\\n     * @notice Transfer funds from department budget\\n     * @param _departmentId Department ID\\n     * @param _recipient Recipient address\\n     * @param _amount Amount to transfer\\n     */\\n    function transferFunds(\\n        uint256 _departmentId,\\n        address _recipient,\\n        uint256 _amount\\n    ) external departmentExists(_departmentId) onlyDepartmentManager(_departmentId) {\\n        require(_recipient != address(0), \\\"Invalid recipient\\\");\\n        require(_amount > 0, \\\"Amount must be greater than 0\\\");\\n\\n        Department storage dept = departments[_departmentId];\\n        require(dept.availableBalance >= _amount, \\\"Insufficient budget\\\");\\n        require(address(this).balance >= _amount, \\\"Insufficient contract balance\\\");\\n\\n        dept.spentAmount += _amount;\\n        dept.availableBalance -= _amount;\\n\\n        (bool success, ) = _recipient.call{value: _amount}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n\\n        emit FundsTransferred(_departmentId, _recipient, _amount);\\n    }\\n\\n    /**\\n     * @notice Get department details\\n     * @param _departmentId Department ID\\n     * @return name Department name\\n     * @return totalBudget Total budget allocated\\n     * @return spentAmount Amount spent\\n     * @return availableBalance Available balance\\n     * @return manager Department manager\\n     * @return active Department active status\\n     */\\n    function getDepartmentDetails(uint256 _departmentId)\\n        external\\n        view\\n        returns (\\n            string memory name,\\n            uint256 totalBudget,\\n            uint256 spentAmount,\\n            uint256 availableBalance,\\n            address manager,\\n            bool active\\n        )\\n    {\\n        Department memory dept = departments[_departmentId];\\n        return (\\n            dept.name,\\n            dept.totalBudget,\\n            dept.spentAmount,\\n            dept.availableBalance,\\n            dept.manager,\\n            dept.active\\n        );\\n    }\\n\\n    /**\\n     * @notice Get department balance\\n     * @param _departmentId Department ID\\n     * @return balance Available balance\\n     */\\n    function getDepartmentBalance(uint256 _departmentId)\\n        external\\n        view\\n        departmentExists(_departmentId)\\n        returns (uint256)\\n    {\\n        return departments[_departmentId].availableBalance;\\n    }\\n\\n    /**\\n     * @notice Get department expenses\\n     * @param _departmentId Department ID\\n     * @return expenses Array of expenses\\n     */\\n    function getDepartmentExpenses(uint256 _departmentId)\\n        external\\n        view\\n        returns (Expense[] memory)\\n    {\\n        return departmentExpenses[_departmentId];\\n    }\\n\\n    /**\\n     * @notice Get total budget across all active departments\\n     * @return total Total budget\\n     */\\n    function getTotalBudget() external view returns (uint256) {\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < departmentCount; i++) {\\n            if (departments[i].active) {\\n                total += departments[i].totalBudget;\\n            }\\n        }\\n        return total;\\n    }\\n\\n    /**\\n     * @notice Get total spent across all departments\\n     * @return total Total spent\\n     */\\n    function getTotalSpent() external view returns (uint256) {\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < departmentCount; i++) {\\n            if (departments[i].active) {\\n                total += departments[i].spentAmount;\\n            }\\n        }\\n        return total;\\n    }\\n\\n    /**\\n     * @notice Get pending fund requests\\n     * @return requests Array of pending request IDs\\n     */\\n    function getPendingRequests() external view returns (uint256[] memory) {\\n        uint256 pendingCount = 0;\\n\\n        // Count pending requests\\n        for (uint256 i = 0; i < requestCount; i++) {\\n            if (!fundRequests[i].approved && !fundRequests[i].rejected) {\\n                pendingCount++;\\n            }\\n        }\\n\\n        // Populate array\\n        uint256[] memory pending = new uint256[](pendingCount);\\n        uint256 index = 0;\\n\\n        for (uint256 i = 0; i < requestCount; i++) {\\n            if (!fundRequests[i].approved && !fundRequests[i].rejected) {\\n                pending[index] = i;\\n                index++;\\n            }\\n        }\\n\\n        return pending;\\n    }\\n\\n    /**\\n     * @notice Deactivate a department\\n     * @param _departmentId Department ID\\n     */\\n    function deactivateDepartment(uint256 _departmentId)\\n        external\\n        onlyAdmin\\n        departmentExists(_departmentId)\\n    {\\n        departments[_departmentId].active = false;\\n        emit DepartmentDeactivated(_departmentId);\\n    }\\n\\n    /**\\n     * @notice Update department manager\\n     * @param _departmentId Department ID\\n     * @param _newManager New manager address\\n     */\\n    function updateDepartmentManager(uint256 _departmentId, address _newManager)\\n        external\\n        onlyAdmin\\n        departmentExists(_departmentId)\\n    {\\n        require(_newManager != address(0), \\\"Invalid manager\\\");\\n        departments[_departmentId].manager = _newManager;\\n    }\\n\\n    /**\\n     * @notice Receive funds from treasury\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @notice Get USDC balance of this contract\\n     * @return balance Current USDC balance\\n     */\\n    function getBalance() external view returns (uint256) {\\n        return usdc.balanceOf(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xb9340d3ab45d03d1f0b1b71d4a8cbb9603517e1c13256ad0c06728d94cbf1033\",\"license\":\"MIT\"},\"contracts/PayrollManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.30;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\n\\n/**\\n * @title PayrollManager\\n * @notice Automated payroll management for treasury operations\\n * @dev Handles employee management, salary payments, and payment scheduling\\n */\\ncontract PayrollManager {\\n    // Enums\\n    enum PaymentFrequency {\\n        WEEKLY,      // Every 7 days\\n        BIWEEKLY,    // Every 14 days\\n        MONTHLY,     // Every 30 days\\n        QUARTERLY    // Every 90 days\\n    }\\n\\n    // Structs\\n    struct Employee {\\n        address wallet;\\n        uint256 salary;\\n        PaymentFrequency frequency;\\n        uint256 lastPaymentTime;\\n        uint256 totalPaid;\\n        bool active;\\n        string name;\\n        uint256 addedAt;\\n    }\\n\\n    struct PaymentRecord {\\n        address employee;\\n        uint256 amount;\\n        uint256 timestamp;\\n        uint256 paymentId;\\n    }\\n\\n    // State variables\\n    address public treasury;\\n    address public admin;\\n    IERC20 public usdc;\\n\\n    mapping(address => Employee) public employees;\\n    address[] public employeeList;\\n    PaymentRecord[] public paymentHistory;\\n\\n    uint256 public totalEmployees;\\n    uint256 public activeEmployees;\\n    uint256 public totalPayrollCost;\\n\\n    // Events\\n    event EmployeeAdded(address indexed employee, string name, uint256 salary, PaymentFrequency frequency);\\n    event EmployeeRemoved(address indexed employee);\\n    event SalaryUpdated(address indexed employee, uint256 oldSalary, uint256 newSalary);\\n    event PaymentProcessed(address indexed employee, uint256 amount, uint256 timestamp);\\n    event PayrollExecuted(uint256 employeesPaid, uint256 totalAmount, uint256 timestamp);\\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\\n\\n    // Modifiers\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"Only admin can call\\\");\\n        _;\\n    }\\n\\n    modifier onlyTreasury() {\\n        require(msg.sender == treasury, \\\"Only treasury can call\\\");\\n        _;\\n    }\\n\\n    modifier employeeExists(address _employee) {\\n        require(employees[_employee].active, \\\"Employee does not exist\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initialize payroll manager\\n     * @param _treasury Treasury contract address\\n     * @param _usdc USDC token address\\n     */\\n    constructor(address _treasury, address _usdc) {\\n        require(_treasury != address(0), \\\"Invalid treasury\\\");\\n        require(_usdc != address(0), \\\"Invalid USDC address\\\");\\n\\n        treasury = _treasury;\\n        admin = msg.sender;\\n        usdc = IERC20(_usdc);\\n    }\\n\\n    /**\\n     * @notice Add a new employee\\n     * @param _employee Employee wallet address\\n     * @param _name Employee name\\n     * @param _salary Annual salary amount\\n     * @param _frequency Payment frequency\\n     */\\n    function addEmployee(\\n        address _employee,\\n        string memory _name,\\n        uint256 _salary,\\n        PaymentFrequency _frequency\\n    ) external onlyAdmin {\\n        require(_employee != address(0), \\\"Invalid employee address\\\");\\n        require(!employees[_employee].active, \\\"Employee already exists\\\");\\n        require(_salary > 0, \\\"Salary must be greater than 0\\\");\\n        require(bytes(_name).length > 0, \\\"Name required\\\");\\n\\n        employees[_employee] = Employee({\\n            wallet: _employee,\\n            salary: _salary,\\n            frequency: _frequency,\\n            lastPaymentTime: 0,\\n            totalPaid: 0,\\n            active: true,\\n            name: _name,\\n            addedAt: block.timestamp\\n        });\\n\\n        employeeList.push(_employee);\\n        totalEmployees++;\\n        activeEmployees++;\\n\\n        emit EmployeeAdded(_employee, _name, _salary, _frequency);\\n    }\\n\\n    /**\\n     * @notice Remove an employee\\n     * @param _employee Employee address to remove\\n     */\\n    function removeEmployee(address _employee) external onlyAdmin employeeExists(_employee) {\\n        employees[_employee].active = false;\\n        activeEmployees--;\\n\\n        emit EmployeeRemoved(_employee);\\n    }\\n\\n    /**\\n     * @notice Update employee salary\\n     * @param _employee Employee address\\n     * @param _newSalary New salary amount\\n     */\\n    function updateSalary(address _employee, uint256 _newSalary)\\n        external\\n        onlyAdmin\\n        employeeExists(_employee)\\n    {\\n        require(_newSalary > 0, \\\"Salary must be greater than 0\\\");\\n\\n        uint256 oldSalary = employees[_employee].salary;\\n        employees[_employee].salary = _newSalary;\\n\\n        emit SalaryUpdated(_employee, oldSalary, _newSalary);\\n    }\\n\\n    /**\\n     * @notice Process payroll for all eligible employees\\n     * @return employeesPaid Number of employees paid\\n     * @return totalPaid Total amount paid\\n     */\\n    function processPayroll() external returns (uint256 employeesPaid, uint256 totalPaid) {\\n        uint256 count = 0;\\n        uint256 total = 0;\\n\\n        for (uint256 i = 0; i < employeeList.length; i++) {\\n            address empAddress = employeeList[i];\\n            Employee storage emp = employees[empAddress];\\n\\n            if (emp.active && isPaymentDue(empAddress)) {\\n                uint256 paymentAmount = calculatePaymentAmount(empAddress);\\n\\n                if (address(this).balance >= paymentAmount) {\\n                    _processPayment(empAddress, paymentAmount);\\n                    count++;\\n                    total += paymentAmount;\\n                }\\n            }\\n        }\\n\\n        if (count > 0) {\\n            emit PayrollExecuted(count, total, block.timestamp);\\n        }\\n\\n        return (count, total);\\n    }\\n\\n    /**\\n     * @notice Process payment for a specific employee\\n     * @param _employee Employee address\\n     */\\n    function processEmployeePayment(address _employee)\\n        external\\n        employeeExists(_employee)\\n        returns (bool)\\n    {\\n        require(isPaymentDue(_employee), \\\"Payment not due yet\\\");\\n\\n        uint256 paymentAmount = calculatePaymentAmount(_employee);\\n        require(address(this).balance >= paymentAmount, \\\"Insufficient balance\\\");\\n\\n        _processPayment(_employee, paymentAmount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Internal function to process payment\\n     * @param _employee Employee address\\n     * @param _amount Payment amount\\n     */\\n    function _processPayment(address _employee, uint256 _amount) internal {\\n        Employee storage emp = employees[_employee];\\n\\n        emp.lastPaymentTime = block.timestamp;\\n        emp.totalPaid += _amount;\\n        totalPayrollCost += _amount;\\n\\n        paymentHistory.push(PaymentRecord({\\n            employee: _employee,\\n            amount: _amount,\\n            timestamp: block.timestamp,\\n            paymentId: paymentHistory.length\\n        }));\\n\\n        (bool success, ) = _employee.call{value: _amount}(\\\"\\\");\\n        require(success, \\\"Payment failed\\\");\\n\\n        emit PaymentProcessed(_employee, _amount, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Check if payment is due for an employee\\n     * @param _employee Employee address\\n     * @return bool Payment due status\\n     */\\n    function isPaymentDue(address _employee) public view returns (bool) {\\n        Employee memory emp = employees[_employee];\\n\\n        if (!emp.active) return false;\\n        if (emp.lastPaymentTime == 0) return true;\\n\\n        uint256 timeElapsed = block.timestamp - emp.lastPaymentTime;\\n        uint256 paymentInterval = getPaymentInterval(emp.frequency);\\n\\n        return timeElapsed >= paymentInterval;\\n    }\\n\\n    /**\\n     * @notice Calculate payment amount based on frequency\\n     * @param _employee Employee address\\n     * @return amount Payment amount\\n     */\\n    function calculatePaymentAmount(address _employee) public view returns (uint256) {\\n        Employee memory emp = employees[_employee];\\n\\n        if (emp.frequency == PaymentFrequency.WEEKLY) {\\n            return emp.salary / 52; // Weekly\\n        } else if (emp.frequency == PaymentFrequency.BIWEEKLY) {\\n            return emp.salary / 26; // Bi-weekly\\n        } else if (emp.frequency == PaymentFrequency.MONTHLY) {\\n            return emp.salary / 12; // Monthly\\n        } else {\\n            return emp.salary / 4; // Quarterly\\n        }\\n    }\\n\\n    /**\\n     * @notice Get payment interval in seconds\\n     * @param _frequency Payment frequency\\n     * @return interval Interval in seconds\\n     */\\n    function getPaymentInterval(PaymentFrequency _frequency) public pure returns (uint256) {\\n        if (_frequency == PaymentFrequency.WEEKLY) {\\n            return 7 days;\\n        } else if (_frequency == PaymentFrequency.BIWEEKLY) {\\n            return 14 days;\\n        } else if (_frequency == PaymentFrequency.MONTHLY) {\\n            return 30 days;\\n        } else {\\n            return 90 days;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get employee details\\n     * @param _employee Employee address\\n     * @return name Employee name\\n     * @return salary Employee salary\\n     * @return frequency Payment frequency\\n     * @return lastPaymentTime Last payment timestamp\\n     * @return totalPaid Total amount paid\\n     * @return active Employee active status\\n     */\\n    function getEmployeeDetails(address _employee)\\n        external\\n        view\\n        returns (\\n            string memory name,\\n            uint256 salary,\\n            PaymentFrequency frequency,\\n            uint256 lastPaymentTime,\\n            uint256 totalPaid,\\n            bool active\\n        )\\n    {\\n        Employee memory emp = employees[_employee];\\n        return (\\n            emp.name,\\n            emp.salary,\\n            emp.frequency,\\n            emp.lastPaymentTime,\\n            emp.totalPaid,\\n            emp.active\\n        );\\n    }\\n\\n    /**\\n     * @notice Get total active payroll cost (annual)\\n     * @return cost Total annual payroll cost\\n     */\\n    function getTotalActivePayrollCost() external view returns (uint256) {\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < employeeList.length; i++) {\\n            if (employees[employeeList[i]].active) {\\n                total += employees[employeeList[i]].salary;\\n            }\\n        }\\n        return total;\\n    }\\n\\n    /**\\n     * @notice Get payment history count\\n     * @return count Number of payments\\n     */\\n    function getPaymentHistoryCount() external view returns (uint256) {\\n        return paymentHistory.length;\\n    }\\n\\n    /**\\n     * @notice Get all active employees\\n     * @return addresses Array of active employee addresses\\n     */\\n    function getActiveEmployees() external view returns (address[] memory) {\\n        address[] memory active = new address[](activeEmployees);\\n        uint256 index = 0;\\n\\n        for (uint256 i = 0; i < employeeList.length; i++) {\\n            if (employees[employeeList[i]].active) {\\n                active[index] = employeeList[i];\\n                index++;\\n            }\\n        }\\n\\n        return active;\\n    }\\n\\n    /**\\n     * @notice Receive funds from treasury\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @notice Change admin\\n     * @param _newAdmin New admin address\\n     */\\n    function changeAdmin(address _newAdmin) external onlyAdmin {\\n        require(_newAdmin != address(0), \\\"Invalid admin\\\");\\n        address oldAdmin = admin;\\n        admin = _newAdmin;\\n        emit AdminChanged(oldAdmin, _newAdmin);\\n    }\\n\\n    /**\\n     * @notice Get USDC balance of this contract\\n     * @return balance Current USDC balance\\n     */\\n    function getBalance() external view returns (uint256) {\\n        return usdc.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @notice Get total payments made to all employees\\n     * @return total Total amount paid out\\n     */\\n    function totalPaymentsMade() external view returns (uint256) {\\n        return totalPayrollCost;\\n    }\\n\\n    /**\\n     * @notice Calculate next payment time for an employee\\n     * @param employeeIndex Index in employeeList\\n     * @return nextPayment Time of next payment\\n     */\\n    function getNextPaymentTime(uint256 employeeIndex) external view returns (uint256) {\\n        require(employeeIndex < employeeList.length, \\\"Invalid index\\\");\\n\\n        address empAddr = employeeList[employeeIndex];\\n        Employee storage emp = employees[empAddr];\\n\\n        if (!emp.active || emp.lastPaymentTime == 0) {\\n            return block.timestamp;\\n        }\\n\\n        uint256 interval;\\n        if (emp.frequency == PaymentFrequency.WEEKLY) {\\n            interval = 7 days;\\n        } else if (emp.frequency == PaymentFrequency.BIWEEKLY) {\\n            interval = 14 days;\\n        } else if (emp.frequency == PaymentFrequency.MONTHLY) {\\n            interval = 30 days;\\n        } else {\\n            interval = 90 days;\\n        }\\n\\n        return emp.lastPaymentTime + interval;\\n    }\\n}\\n\",\"keccak256\":\"0xbe9728837d15dc2aa0ac798798cad5621f1387db7d9938fcf3797915d96462d3\",\"license\":\"MIT\"},\"contracts/ScheduledPayments.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.30;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\n\\n/**\\n * @title ScheduledPayments\\n * @notice Automated scheduled payment system for treasury operations\\n * @dev Handles one-time and recurring payments with time-based execution\\n */\\ncontract ScheduledPayments {\\n    // Enums\\n    enum PaymentStatus {\\n        PENDING,\\n        EXECUTED,\\n        CANCELLED,\\n        FAILED\\n    }\\n\\n    // Structs\\n    struct ScheduledPayment {\\n        uint256 id;\\n        address recipient;\\n        uint256 amount;\\n        uint256 executeAt;\\n        bool recurring;\\n        uint256 interval; // For recurring payments (in seconds)\\n        uint256 executionCount;\\n        uint256 maxExecutions; // 0 = unlimited\\n        PaymentStatus status;\\n        address creator;\\n        uint256 createdAt;\\n        uint256 lastExecutedAt;\\n        string description;\\n    }\\n\\n    // State variables\\n    address public treasury;\\n    address public admin;\\n    IERC20 public usdc;\\n\\n    mapping(uint256 => ScheduledPayment) public payments;\\n    uint256 public paymentCount;\\n\\n    uint256[] public pendingPayments;\\n    mapping(uint256 => bool) public isPending;\\n\\n    // Events\\n    event PaymentScheduled(\\n        uint256 indexed paymentId,\\n        address indexed recipient,\\n        uint256 amount,\\n        uint256 executeAt,\\n        bool recurring\\n    );\\n    event PaymentExecuted(uint256 indexed paymentId, uint256 amount, uint256 timestamp);\\n    event PaymentCancelled(uint256 indexed paymentId, address indexed canceller);\\n    event PaymentFailed(uint256 indexed paymentId, string reason);\\n    event RecurringPaymentCompleted(uint256 indexed paymentId, uint256 totalExecutions);\\n\\n    // Modifiers\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"Only admin can call\\\");\\n        _;\\n    }\\n\\n    modifier onlyTreasury() {\\n        require(msg.sender == treasury, \\\"Only treasury can call\\\");\\n        _;\\n    }\\n\\n    modifier paymentExists(uint256 _paymentId) {\\n        require(_paymentId < paymentCount, \\\"Payment does not exist\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initialize scheduled payments\\n     * @param _treasury Treasury contract address\\n     * @param _usdc USDC token address\\n     */\\n    constructor(address _treasury, address _usdc) {\\n        require(_treasury != address(0), \\\"Invalid treasury\\\");\\n        require(_usdc != address(0), \\\"Invalid USDC address\\\");\\n\\n        treasury = _treasury;\\n        admin = msg.sender;\\n        usdc = IERC20(_usdc);\\n    }\\n\\n    /**\\n     * @notice Schedule a new payment\\n     * @param _recipient Payment recipient\\n     * @param _amount Payment amount\\n     * @param _executeAt Execution timestamp\\n     * @param _recurring Whether payment is recurring\\n     * @param _interval Interval for recurring payments (seconds)\\n     * @param _maxExecutions Maximum executions (0 = unlimited)\\n     * @param _description Payment description\\n     * @return paymentId Payment ID\\n     */\\n    function schedulePayment(\\n        address _recipient,\\n        uint256 _amount,\\n        uint256 _executeAt,\\n        bool _recurring,\\n        uint256 _interval,\\n        uint256 _maxExecutions,\\n        string memory _description\\n    ) external onlyAdmin returns (uint256) {\\n        require(_recipient != address(0), \\\"Invalid recipient\\\");\\n        require(_amount > 0, \\\"Amount must be greater than 0\\\");\\n        require(_executeAt > block.timestamp, \\\"Execution time must be in future\\\");\\n\\n        if (_recurring) {\\n            require(_interval > 0, \\\"Interval required for recurring payments\\\");\\n        }\\n\\n        uint256 paymentId = paymentCount;\\n\\n        payments[paymentId] = ScheduledPayment({\\n            id: paymentId,\\n            recipient: _recipient,\\n            amount: _amount,\\n            executeAt: _executeAt,\\n            recurring: _recurring,\\n            interval: _interval,\\n            executionCount: 0,\\n            maxExecutions: _maxExecutions,\\n            status: PaymentStatus.PENDING,\\n            creator: msg.sender,\\n            createdAt: block.timestamp,\\n            lastExecutedAt: 0,\\n            description: _description\\n        });\\n\\n        pendingPayments.push(paymentId);\\n        isPending[paymentId] = true;\\n\\n        paymentCount++;\\n\\n        emit PaymentScheduled(paymentId, _recipient, _amount, _executeAt, _recurring);\\n\\n        return paymentId;\\n    }\\n\\n    /**\\n     * @notice Execute a scheduled payment\\n     * @param _paymentId Payment ID\\n     */\\n    function executeScheduledPayment(uint256 _paymentId)\\n        external\\n        paymentExists(_paymentId)\\n        returns (bool)\\n    {\\n        ScheduledPayment storage payment = payments[_paymentId];\\n\\n        require(payment.status == PaymentStatus.PENDING, \\\"Payment not pending\\\");\\n        require(block.timestamp >= payment.executeAt, \\\"Payment not due yet\\\");\\n        require(address(this).balance >= payment.amount, \\\"Insufficient balance\\\");\\n\\n        // Check if max executions reached\\n        if (payment.maxExecutions > 0 && payment.executionCount >= payment.maxExecutions) {\\n            payment.status = PaymentStatus.EXECUTED;\\n            _removePendingPayment(_paymentId);\\n            emit RecurringPaymentCompleted(_paymentId, payment.executionCount);\\n            return false;\\n        }\\n\\n        // Execute payment\\n        (bool success, ) = payment.recipient.call{value: payment.amount}(\\\"\\\");\\n\\n        if (!success) {\\n            emit PaymentFailed(_paymentId, \\\"Transfer failed\\\");\\n            return false;\\n        }\\n\\n        payment.executionCount++;\\n        payment.lastExecutedAt = block.timestamp;\\n\\n        emit PaymentExecuted(_paymentId, payment.amount, block.timestamp);\\n\\n        // Handle recurring payment\\n        if (payment.recurring) {\\n            payment.executeAt = block.timestamp + payment.interval;\\n\\n            // Check if max executions reached\\n            if (payment.maxExecutions > 0 && payment.executionCount >= payment.maxExecutions) {\\n                payment.status = PaymentStatus.EXECUTED;\\n                _removePendingPayment(_paymentId);\\n                emit RecurringPaymentCompleted(_paymentId, payment.executionCount);\\n            }\\n        } else {\\n            payment.status = PaymentStatus.EXECUTED;\\n            _removePendingPayment(_paymentId);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Execute all due payments\\n     * @return executed Number of payments executed\\n     */\\n    function executeAllDuePayments() external returns (uint256 executed) {\\n        uint256 count = 0;\\n\\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\\n            uint256 paymentId = pendingPayments[i];\\n            ScheduledPayment storage payment = payments[paymentId];\\n\\n            if (\\n                payment.status == PaymentStatus.PENDING &&\\n                block.timestamp >= payment.executeAt &&\\n                address(this).balance >= payment.amount\\n            ) {\\n                if (this.executeScheduledPayment(paymentId)) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    /**\\n     * @notice Cancel a scheduled payment\\n     * @param _paymentId Payment ID\\n     */\\n    function cancelScheduledPayment(uint256 _paymentId)\\n        external\\n        onlyAdmin\\n        paymentExists(_paymentId)\\n    {\\n        ScheduledPayment storage payment = payments[_paymentId];\\n        require(payment.status == PaymentStatus.PENDING, \\\"Payment not pending\\\");\\n\\n        payment.status = PaymentStatus.CANCELLED;\\n        _removePendingPayment(_paymentId);\\n\\n        emit PaymentCancelled(_paymentId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Remove payment from pending list\\n     * @param _paymentId Payment ID\\n     */\\n    function _removePendingPayment(uint256 _paymentId) internal {\\n        if (!isPending[_paymentId]) return;\\n\\n        isPending[_paymentId] = false;\\n\\n        // Find and remove from array\\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\\n            if (pendingPayments[i] == _paymentId) {\\n                pendingPayments[i] = pendingPayments[pendingPayments.length - 1];\\n                pendingPayments.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Get upcoming payments (next 7 days)\\n     * @return upcomingIds Array of upcoming payment IDs\\n     */\\n    function getUpcomingPayments() external view returns (uint256[] memory) {\\n        uint256 weekFromNow = block.timestamp + 7 days;\\n        uint256 upcomingCount = 0;\\n\\n        // Count upcoming payments\\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\\n            uint256 paymentId = pendingPayments[i];\\n            if (payments[paymentId].executeAt <= weekFromNow) {\\n                upcomingCount++;\\n            }\\n        }\\n\\n        // Populate array\\n        uint256[] memory upcoming = new uint256[](upcomingCount);\\n        uint256 index = 0;\\n\\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\\n            uint256 paymentId = pendingPayments[i];\\n            if (payments[paymentId].executeAt <= weekFromNow) {\\n                upcoming[index] = paymentId;\\n                index++;\\n            }\\n        }\\n\\n        return upcoming;\\n    }\\n\\n    /**\\n     * @notice Get due payments\\n     * @return dueIds Array of due payment IDs\\n     */\\n    function getDuePayments() external view returns (uint256[] memory) {\\n        uint256 dueCount = 0;\\n\\n        // Count due payments\\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\\n            uint256 paymentId = pendingPayments[i];\\n            if (\\n                payments[paymentId].status == PaymentStatus.PENDING &&\\n                block.timestamp >= payments[paymentId].executeAt\\n            ) {\\n                dueCount++;\\n            }\\n        }\\n\\n        // Populate array\\n        uint256[] memory due = new uint256[](dueCount);\\n        uint256 index = 0;\\n\\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\\n            uint256 paymentId = pendingPayments[i];\\n            if (\\n                payments[paymentId].status == PaymentStatus.PENDING &&\\n                block.timestamp >= payments[paymentId].executeAt\\n            ) {\\n                due[index] = paymentId;\\n                index++;\\n            }\\n        }\\n\\n        return due;\\n    }\\n\\n    /**\\n     * @notice Get payment details\\n     * @param _paymentId Payment ID\\n     * @return recipient Payment recipient\\n     * @return amount Payment amount\\n     * @return executeAt Execution timestamp\\n     * @return recurring Recurring status\\n     * @return executionCount Number of executions\\n     * @return status Payment status\\n     * @return description Payment description\\n     */\\n    function getPaymentDetails(uint256 _paymentId)\\n        external\\n        view\\n        paymentExists(_paymentId)\\n        returns (\\n            address recipient,\\n            uint256 amount,\\n            uint256 executeAt,\\n            bool recurring,\\n            uint256 executionCount,\\n            PaymentStatus status,\\n            string memory description\\n        )\\n    {\\n        ScheduledPayment memory payment = payments[_paymentId];\\n        return (\\n            payment.recipient,\\n            payment.amount,\\n            payment.executeAt,\\n            payment.recurring,\\n            payment.executionCount,\\n            payment.status,\\n            payment.description\\n        );\\n    }\\n\\n    /**\\n     * @notice Get all pending payment IDs\\n     * @return Array of pending payment IDs\\n     */\\n    function getPendingPaymentIds() external view returns (uint256[] memory) {\\n        return pendingPayments;\\n    }\\n\\n    /**\\n     * @notice Check if payment is due\\n     * @param _paymentId Payment ID\\n     * @return bool Payment due status\\n     */\\n    function isPaymentDue(uint256 _paymentId)\\n        external\\n        view\\n        paymentExists(_paymentId)\\n        returns (bool)\\n    {\\n        ScheduledPayment memory payment = payments[_paymentId];\\n        return (\\n            payment.status == PaymentStatus.PENDING &&\\n            block.timestamp >= payment.executeAt\\n        );\\n    }\\n\\n    /**\\n     * @notice Get total pending payment amount\\n     * @return total Total pending amount\\n     */\\n    function getTotalPendingAmount() external view returns (uint256) {\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < pendingPayments.length; i++) {\\n            total += payments[pendingPayments[i]].amount;\\n        }\\n        return total;\\n    }\\n\\n    /**\\n     * @notice Receive funds from treasury\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @notice Get USDC balance of this contract\\n     * @return balance Current USDC balance\\n     */\\n    function getBalance() external view returns (uint256) {\\n        return usdc.balanceOf(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xb008a4133a1d6dd33de3fe3551e58090dc270ba0da8d1b079e317b49e370d840\",\"license\":\"MIT\"},\"contracts/TreasuryAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.30;\\n\\nimport \\\"./TreasuryCore.sol\\\";\\nimport \\\"./PayrollManager.sol\\\";\\nimport \\\"./BudgetAllocator.sol\\\";\\nimport \\\"./ScheduledPayments.sol\\\";\\n\\n/**\\n * @title TreasuryAggregatorSimple\\n * @notice Simplified unified view for MVP\\n */\\ncontract TreasuryAggregatorSimple {\\n    TreasuryCore public treasuryCore;\\n    PayrollManager public payrollManager;\\n    BudgetAllocator public budgetAllocator;\\n    ScheduledPayments public scheduledPayments;\\n\\n    struct TreasurySnapshot {\\n        uint256 totalBalance;\\n        uint256 treasuryBalance;\\n        uint256 payrollBalance;\\n        uint256 budgetBalance;\\n        uint256 scheduledBalance;\\n        uint256 timestamp;\\n    }\\n\\n    constructor(\\n        address _treasuryCore,\\n        address _payrollManager,\\n        address _budgetAllocator,\\n        address _scheduledPayments\\n    ) {\\n        treasuryCore = TreasuryCore(payable(_treasuryCore));\\n        payrollManager = PayrollManager(payable(_payrollManager));\\n        budgetAllocator = BudgetAllocator(payable(_budgetAllocator));\\n        scheduledPayments = ScheduledPayments(payable(_scheduledPayments));\\n    }\\n\\n    function getTreasurySnapshot() external view returns (TreasurySnapshot memory) {\\n        uint256 treasuryBal = treasuryCore.getBalance();\\n        uint256 payrollBal = payrollManager.getBalance();\\n        uint256 budgetBal = budgetAllocator.getBalance();\\n        uint256 scheduledBal = scheduledPayments.getBalance();\\n\\n        return TreasurySnapshot({\\n            totalBalance: treasuryBal + payrollBal + budgetBal + scheduledBal,\\n            treasuryBalance: treasuryBal,\\n            payrollBalance: payrollBal,\\n            budgetBalance: budgetBal,\\n            scheduledBalance: scheduledBal,\\n            timestamp: block.timestamp\\n        });\\n    }\\n\\n    function getBasicStats() external view returns (\\n        uint256 totalEmployees,\\n        uint256 totalDepartments,\\n        uint256 totalScheduledPayments,\\n        uint256 totalTransactions\\n    ) {\\n        return (\\n            payrollManager.totalEmployees(),\\n            budgetAllocator.departmentCount(),\\n            scheduledPayments.paymentCount(),\\n            treasuryCore.transactionCount()\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xf65bceb45fc6547020e62fc913659961ef2913b3c865a96db0cffdb6875d5545\",\"license\":\"MIT\"},\"contracts/TreasuryCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.30;\\n\\n/**\\n * @title TreasuryCore\\n * @notice Core treasury management contract with multi-signature functionality\\n * @dev Manages treasury funds, proposals, and multi-sig approvals\\n */\\ncontract TreasuryCore {\\n    // Events\\n    event FundsDeposited(address indexed from, uint256 amount, uint256 timestamp);\\n    event TransactionProposed(uint256 indexed txId, address indexed proposer, address to, uint256 amount);\\n    event TransactionApproved(uint256 indexed txId, address indexed approver);\\n    event TransactionExecuted(uint256 indexed txId, address indexed executor);\\n    event TransactionCancelled(uint256 indexed txId, address indexed canceller);\\n    event OwnerAdded(address indexed owner);\\n    event OwnerRemoved(address indexed owner);\\n    event ThresholdChanged(uint256 newThreshold);\\n    event Paused(address indexed by);\\n    event Unpaused(address indexed by);\\n\\n    // Structs\\n    struct Transaction {\\n        address to;\\n        uint256 amount;\\n        bytes data;\\n        bool executed;\\n        bool cancelled;\\n        uint256 approvalCount;\\n        uint256 proposedAt;\\n        address proposer;\\n    }\\n\\n    // State variables\\n    mapping(address => bool) public isOwner;\\n    address[] public owners;\\n    uint256 public threshold;\\n\\n    Transaction[] public transactions;\\n    mapping(uint256 => mapping(address => bool)) public hasApproved;\\n\\n    bool public paused;\\n\\n    // Modifiers\\n    modifier onlyOwner() {\\n        require(isOwner[msg.sender], \\\"Not an owner\\\");\\n        _;\\n    }\\n\\n    modifier txExists(uint256 _txId) {\\n        require(_txId < transactions.length, \\\"Transaction does not exist\\\");\\n        _;\\n    }\\n\\n    modifier notExecuted(uint256 _txId) {\\n        require(!transactions[_txId].executed, \\\"Transaction already executed\\\");\\n        _;\\n    }\\n\\n    modifier notCancelled(uint256 _txId) {\\n        require(!transactions[_txId].cancelled, \\\"Transaction cancelled\\\");\\n        _;\\n    }\\n\\n    modifier notApproved(uint256 _txId) {\\n        require(!hasApproved[_txId][msg.sender], \\\"Transaction already approved\\\");\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"Contract is paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused, \\\"Contract is not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initialize the treasury with owners and approval threshold\\n     * @param _owners Array of owner addresses\\n     * @param _threshold Number of approvals required for execution\\n     */\\n    constructor(address[] memory _owners, uint256 _threshold) {\\n        require(_owners.length > 0, \\\"Owners required\\\");\\n        require(_threshold > 0 && _threshold <= _owners.length, \\\"Invalid threshold\\\");\\n\\n        for (uint256 i = 0; i < _owners.length; i++) {\\n            address owner = _owners[i];\\n            require(owner != address(0), \\\"Invalid owner\\\");\\n            require(!isOwner[owner], \\\"Duplicate owner\\\");\\n\\n            isOwner[owner] = true;\\n            owners.push(owner);\\n        }\\n\\n        threshold = _threshold;\\n    }\\n\\n    /**\\n     * @notice Receive USDC deposits\\n     */\\n    receive() external payable {\\n        emit FundsDeposited(msg.sender, msg.value, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Get the current treasury balance\\n     * @return balance Current balance in wei\\n     */\\n    function getBalance() external view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    /**\\n     * @notice Propose a new transaction\\n     * @param _to Recipient address\\n     * @param _amount Amount to send\\n     * @param _data Additional data for the transaction\\n     * @return txId Transaction ID\\n     */\\n    function proposeTransaction(\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _data\\n    ) external onlyOwner whenNotPaused returns (uint256) {\\n        require(_to != address(0), \\\"Invalid recipient\\\");\\n\\n        uint256 txId = transactions.length;\\n\\n        transactions.push(Transaction({\\n            to: _to,\\n            amount: _amount,\\n            data: _data,\\n            executed: false,\\n            cancelled: false,\\n            approvalCount: 0,\\n            proposedAt: block.timestamp,\\n            proposer: msg.sender\\n        }));\\n\\n        emit TransactionProposed(txId, msg.sender, _to, _amount);\\n\\n        return txId;\\n    }\\n\\n    /**\\n     * @notice Approve a proposed transaction\\n     * @param _txId Transaction ID to approve\\n     */\\n    function approveTransaction(uint256 _txId)\\n        external\\n        onlyOwner\\n        txExists(_txId)\\n        notExecuted(_txId)\\n        notCancelled(_txId)\\n        notApproved(_txId)\\n        whenNotPaused\\n    {\\n        hasApproved[_txId][msg.sender] = true;\\n        transactions[_txId].approvalCount += 1;\\n\\n        emit TransactionApproved(_txId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Execute an approved transaction\\n     * @param _txId Transaction ID to execute\\n     */\\n    function executeTransaction(uint256 _txId)\\n        external\\n        onlyOwner\\n        txExists(_txId)\\n        notExecuted(_txId)\\n        notCancelled(_txId)\\n        whenNotPaused\\n    {\\n        Transaction storage txn = transactions[_txId];\\n\\n        require(txn.approvalCount >= threshold, \\\"Insufficient approvals\\\");\\n        require(address(this).balance >= txn.amount, \\\"Insufficient balance\\\");\\n\\n        txn.executed = true;\\n\\n        (bool success, ) = txn.to.call{value: txn.amount}(txn.data);\\n        require(success, \\\"Transaction execution failed\\\");\\n\\n        emit TransactionExecuted(_txId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Cancel a proposed transaction\\n     * @param _txId Transaction ID to cancel\\n     */\\n    function cancelTransaction(uint256 _txId)\\n        external\\n        onlyOwner\\n        txExists(_txId)\\n        notExecuted(_txId)\\n        notCancelled(_txId)\\n    {\\n        Transaction storage txn = transactions[_txId];\\n        require(txn.proposer == msg.sender, \\\"Only proposer can cancel\\\");\\n\\n        txn.cancelled = true;\\n\\n        emit TransactionCancelled(_txId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Pause the contract (emergency)\\n     */\\n    function pause() external onlyOwner whenNotPaused {\\n        paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Unpause the contract\\n     */\\n    function unpause() external onlyOwner whenPaused {\\n        paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Get transaction details\\n     * @param _txId Transaction ID\\n     * @return to Recipient address\\n     * @return amount Transaction amount\\n     * @return data Transaction data\\n     * @return executed Execution status\\n     * @return cancelled Cancellation status\\n     * @return approvalCount Number of approvals\\n     */\\n    function getTransaction(uint256 _txId)\\n        external\\n        view\\n        txExists(_txId)\\n        returns (\\n            address to,\\n            uint256 amount,\\n            bytes memory data,\\n            bool executed,\\n            bool cancelled,\\n            uint256 approvalCount\\n        )\\n    {\\n        Transaction memory txn = transactions[_txId];\\n        return (\\n            txn.to,\\n            txn.amount,\\n            txn.data,\\n            txn.executed,\\n            txn.cancelled,\\n            txn.approvalCount\\n        );\\n    }\\n\\n    /**\\n     * @notice Get total number of transactions\\n     * @return count Transaction count\\n     */\\n    function getTransactionCount() external view returns (uint256) {\\n        return transactions.length;\\n    }\\n\\n    /**\\n     * @notice Get all owners\\n     * @return Array of owner addresses\\n     */\\n    function getOwners() external view returns (address[] memory) {\\n        return owners;\\n    }\\n\\n    /**\\n     * @notice Check if transaction is approved by an owner\\n     * @param _txId Transaction ID\\n     * @param _owner Owner address\\n     * @return bool Approval status\\n     */\\n    function isApproved(uint256 _txId, address _owner) external view returns (bool) {\\n        return hasApproved[_txId][_owner];\\n    }\\n\\n    /**\\n     * @notice Get total number of transactions\\n     * @return count Total transactions\\n     */\\n    function transactionCount() external view returns (uint256) {\\n        return transactions.length;\\n    }\\n}\\n\",\"keccak256\":\"0x51821f0ba82a9e421c6bfb5fb1eee8853068c225e10226c98f0c610b33632634\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.30;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\",\"keccak256\":\"0xfa5783485783f404dd3d24313d198c518fedb23ffe9351214e7a54f2a9fc2e82\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60803460bd57601f6106d938819003918201601f19168301916001600160401b0383118484101760c25780849260809460405283398101031260bd5760428160d8565b90604d6020820160d8565b60616060605b6040850160d8565b930160d8565b600080546001600160a01b03199081166001600160a01b0396871617909155600180548216938616939093179092556002805483169385169390931790925560038054909116919092161790556040516105ed90816100ec8239f35b600080fd5b634e487b7160e01b600052604160045260246000fd5b51906001600160a01b038216820360bd5756fe608080604052600436101561001357600080fd5b60003560e01c908163443c88441461051c575080636ace1488146104f35780638b695a0414610326578063965501c7146102fd578063c08e7c711461008f5763d0b678341461006157600080fd5b3461008a57600036600319011261008a576000546040516001600160a01b039091168152602090f35b600080fd5b3461008a57600036600319011261008a57600060a06040516100b081610540565b82815282602082015282604082015282606082015282608082015201526004602060018060a01b036000541660405192838092629032ff60e51b82525afa90811561024c576000916102c6575b50600154604051629032ff60e51b81529190602090839060049082906001600160a01b03165afa91821561024c5760009261028f575b50600254604051629032ff60e51b8152929190602090849060049082906001600160a01b03165afa92831561024c57600093610258575b50600354604051629032ff60e51b81529390602090859060049082906001600160a01b03165afa93841561024c57600094610215575b5092836101bc826101b760c0976101b78888610594565b610594565b9360a06040516101cb81610540565b8681526020810195865260408101928352606081019384526080810194855201934285526040519586525160208601525160408501525160608401525160808301525160a0820152f35b6020813d602011610244575b8161022e60209383610572565b810103126102405751935060c06101a0565b8480fd5b3d9150610221565b6040513d6000823e3d90fd5b6020813d602011610287575b8161027160209383610572565b8101031261028357519250600461016a565b8380fd5b3d9150610264565b6020813d6020116102be575b816102a860209383610572565b810103126102ba575191506004610133565b8280fd5b3d915061029b565b6020813d6020116102f5575b816102df60209383610572565b810103126102f15751905060046100fd565b5080fd5b3d91506102d2565b3461008a57600036600319011261008a576001546040516001600160a01b039091168152602090f35b3461008a57600036600319011261008a576001546040516352b9b97360e01b815290602090829060049082906001600160a01b03165afa801561024c576000906104c0575b60025460405163aaa3cd4760e01b81529250602090839060049082906001600160a01b03165afa801561024c5760009061048d575b60035460405163049bf34560e11b81529350602090849060049082906001600160a01b03165afa801561024c5760009061045a575b600054604051625bbdfb60e91b81529450602090859060049082906001600160a01b03165afa91821561024c57600092610425575b60809450604051938452602084015260408301526060820152f35b91506020843d602011610452575b8161044060209383610572565b8101031261008a57608093519161040a565b3d9150610433565b506020833d602011610485575b8161047460209383610572565b8101031261008a57600492516103d5565b3d9150610467565b506020823d6020116104b8575b816104a760209383610572565b8101031261008a57600491516103a0565b3d915061049a565b506020813d6020116104eb575b816104da60209383610572565b8101031261008a576004905161036b565b3d91506104cd565b3461008a57600036600319011261008a576002546040516001600160a01b039091168152602090f35b3461008a57600036600319011261008a576003546001600160a01b03168152602090f35b60c0810190811067ffffffffffffffff82111761055c57604052565b634e487b7160e01b600052604160045260246000fd5b90601f8019910116810190811067ffffffffffffffff82111761055c57604052565b919082018092116105a157565b634e487b7160e01b600052601160045260246000fdfea2646970667358221220fb33c0272e009b53bb167df874410acfc23a9fd302a34b747cb20cd90d8b0a5064736f6c634300081e0033",
  "deployedBytecode": "0x608080604052600436101561001357600080fd5b60003560e01c908163443c88441461051c575080636ace1488146104f35780638b695a0414610326578063965501c7146102fd578063c08e7c711461008f5763d0b678341461006157600080fd5b3461008a57600036600319011261008a576000546040516001600160a01b039091168152602090f35b600080fd5b3461008a57600036600319011261008a57600060a06040516100b081610540565b82815282602082015282604082015282606082015282608082015201526004602060018060a01b036000541660405192838092629032ff60e51b82525afa90811561024c576000916102c6575b50600154604051629032ff60e51b81529190602090839060049082906001600160a01b03165afa91821561024c5760009261028f575b50600254604051629032ff60e51b8152929190602090849060049082906001600160a01b03165afa92831561024c57600093610258575b50600354604051629032ff60e51b81529390602090859060049082906001600160a01b03165afa93841561024c57600094610215575b5092836101bc826101b760c0976101b78888610594565b610594565b9360a06040516101cb81610540565b8681526020810195865260408101928352606081019384526080810194855201934285526040519586525160208601525160408501525160608401525160808301525160a0820152f35b6020813d602011610244575b8161022e60209383610572565b810103126102405751935060c06101a0565b8480fd5b3d9150610221565b6040513d6000823e3d90fd5b6020813d602011610287575b8161027160209383610572565b8101031261028357519250600461016a565b8380fd5b3d9150610264565b6020813d6020116102be575b816102a860209383610572565b810103126102ba575191506004610133565b8280fd5b3d915061029b565b6020813d6020116102f5575b816102df60209383610572565b810103126102f15751905060046100fd565b5080fd5b3d91506102d2565b3461008a57600036600319011261008a576001546040516001600160a01b039091168152602090f35b3461008a57600036600319011261008a576001546040516352b9b97360e01b815290602090829060049082906001600160a01b03165afa801561024c576000906104c0575b60025460405163aaa3cd4760e01b81529250602090839060049082906001600160a01b03165afa801561024c5760009061048d575b60035460405163049bf34560e11b81529350602090849060049082906001600160a01b03165afa801561024c5760009061045a575b600054604051625bbdfb60e91b81529450602090859060049082906001600160a01b03165afa91821561024c57600092610425575b60809450604051938452602084015260408301526060820152f35b91506020843d602011610452575b8161044060209383610572565b8101031261008a57608093519161040a565b3d9150610433565b506020833d602011610485575b8161047460209383610572565b8101031261008a57600492516103d5565b3d9150610467565b506020823d6020116104b8575b816104a760209383610572565b8101031261008a57600491516103a0565b3d915061049a565b506020813d6020116104eb575b816104da60209383610572565b8101031261008a576004905161036b565b3d91506104cd565b3461008a57600036600319011261008a576002546040516001600160a01b039091168152602090f35b3461008a57600036600319011261008a576003546001600160a01b03168152602090f35b60c0810190811067ffffffffffffffff82111761055c57604052565b634e487b7160e01b600052604160045260246000fd5b90601f8019910116810190811067ffffffffffffffff82111761055c57604052565b919082018092116105a157565b634e487b7160e01b600052601160045260246000fdfea2646970667358221220fb33c0272e009b53bb167df874410acfc23a9fd302a34b747cb20cd90d8b0a5064736f6c634300081e0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "title": "TreasuryAggregatorSimple",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Simplified unified view for MVP",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 6203,
        "contract": "contracts/TreasuryAggregator.sol:TreasuryAggregatorSimple",
        "label": "treasuryCore",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(TreasuryCore)6999"
      },
      {
        "astId": 6206,
        "contract": "contracts/TreasuryAggregator.sol:TreasuryAggregatorSimple",
        "label": "payrollManager",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(PayrollManager)4097"
      },
      {
        "astId": 6209,
        "contract": "contracts/TreasuryAggregator.sol:TreasuryAggregatorSimple",
        "label": "budgetAllocator",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(BudgetAllocator)1781"
      },
      {
        "astId": 6212,
        "contract": "contracts/TreasuryAggregator.sol:TreasuryAggregatorSimple",
        "label": "scheduledPayments",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(ScheduledPayments)6193"
      }
    ],
    "types": {
      "t_contract(BudgetAllocator)1781": {
        "encoding": "inplace",
        "label": "contract BudgetAllocator",
        "numberOfBytes": "20"
      },
      "t_contract(PayrollManager)4097": {
        "encoding": "inplace",
        "label": "contract PayrollManager",
        "numberOfBytes": "20"
      },
      "t_contract(ScheduledPayments)6193": {
        "encoding": "inplace",
        "label": "contract ScheduledPayments",
        "numberOfBytes": "20"
      },
      "t_contract(TreasuryCore)6999": {
        "encoding": "inplace",
        "label": "contract TreasuryCore",
        "numberOfBytes": "20"
      }
    }
  }
}